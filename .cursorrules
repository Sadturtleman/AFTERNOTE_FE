# Project Context
- **Project Type**: Android App (Kotlin, Jetpack Compose)
- **Architecture**: Clean Architecture (Data, Domain, Presentation Layers)
- **Dependency Injection**: Hilt
- **Navigation**: Navigation Compose (Type-safe with kotlinx.serialization)
- **Code Quality**: Detekt
- **JDK**: JDK 21 (Eclipse Adoptium)

---

# 1. Architecture Rules (아키텍처 규칙)

## Layer Separation (계층 분리)
모든 Feature 모듈은 아래 3계층을 엄격히 준수해야 합니다.

1. **Domain Layer** (Pure Kotlin)
   - 외부 의존성(Android Framework, Data Layer 등)을 가지지 않습니다.
   - `Entity`, `Repository Interface`, `UseCase`가 위치합니다.
   - 비즈니스 로직의 핵심입니다.

2. **Data Layer**
   - Domain Layer의 `Repository`를 구현(`Impl`)합니다.
   - API 호출, DB 접근, DTO 매핑을 담당합니다.
   - `Mapper`를 통해 DTO를 Domain Entity로 변환하여 반환합니다.

3. **Presentation Layer**
   - UI (`Screen`, `Component`)와 상태 관리 (`ViewModel`)를 담당합니다.
   - Domain Layer의 `UseCase`를 주입받아 비즈니스 로직을 수행합니다.
   - `UiModel`을 정의하여 UI에 필요한 데이터만 가공해 보여줍니다.

## Dependency Flow (의존성 방향)
- **Correct**: Presentation → Domain ← Data
- **Incorrect**: Domain → Data (X), Domain → Presentation (X)

---

# 2. Jetpack Compose Rules (Compose 규칙)

## Composable Functions
1. **State Hoisting**: 상태(`State`)는 호출부로 끌어올리고, Composable은 상태를 인자로 받아야 합니다 (Stateless 지향).
2. **Modifier**: 모든 Composable 함수는 `modifier: Modifier = Modifier`를 첫 번째 선택적 파라미터로 받아야 합니다.
3. **Preview (필수)**: **모든 public Composable 함수는 반드시 `@Preview` 어노테이션을 사용한 Preview 함수를 포함해야 합니다.**
   - Preview 함수는 `private`으로 선언하고, `@Preview(showBackground = true)`를 사용합니다.
   - 다양한 상태를 보여주는 것이 좋습니다 (선택됨/선택 안 됨, 활성화/비활성화 등).
   - 예외:
     * 내부 전용 컴포넌트(`internal` 함수)는 선택적으로 작성 가능
     * Navigation Graph Builder 확장 함수 (`NavGraphBuilder` 확장 함수)
     * ViewModel이나 Repository 같은 비UI 컴포넌트

## File Structure
- **One Component per File**: 하나의 파일에는 하나의 주요 `@Composable` 함수와 해당 `@Preview`만 위치시킵니다.
   - 예외: 비공개(`private`) 하위 컴포넌트나 data class, enum 등은 같은 파일에 둘 수 있습니다.

- **File Length Limit**: 파일이 400줄을 넘어가면 여러 파일로 분리해야 합니다.
   - 파일이 너무 길어지면 가독성과 유지보수성이 저하됩니다.
   - 분리 방법:
     * 관련된 기능이나 책임을 기준으로 논리적으로 분리합니다.
     * 공통적으로 사용되는 로직은 별도의 유틸리티 함수나 헬퍼 컴포넌트로 추출합니다.
     * 큰 컴포넌트는 더 작은 하위 컴포넌트들로 분해합니다.
   - 예외: 자동 생성 코드나 데이터 클래스만 포함하는 파일은 예외적으로 더 길 수 있습니다.

- **Folder Structure Reorganization (폴더 구조 재구성)**: 한 폴더에 파일이 너무 많아지면(예: 15개 이상) 해당 폴더 내에서 하위 폴더로 재구성해야 합니다.
   - 재구성 기준:
     * 기능별로 그룹화 (예: `component/common/`, `component/detail/`, `component/edit/`)
     * 책임별로 그룹화 (예: `presentation/screen/`, `presentation/component/`, `presentation/viewmodel/`)
     * 계층별로 그룹화 (예: `domain/usecase/`, `domain/repository/`, `data/datasource/`)
   - 재구성 방법:
     * 관련된 파일들을 논리적으로 묶을 수 있는 하위 폴더를 생성합니다.
     * 기존 파일들을 적절한 하위 폴더로 이동합니다.
     * 패키지 선언을 새로운 폴더 구조에 맞게 업데이트합니다.
   - 예외: 자동 생성 파일이나 설정 파일이 많은 경우는 예외적으로 더 많은 파일을 허용할 수 있습니다.

## Component Spacing
- 특정 컴포넌트(예: Text)에만 `padding`을 사용하여 다음 컴포넌트와의 간격을 처리하지 말아야 합니다.
- 모든 컴포넌트에 일관되게 간격 처리 방법을 적용해야 합니다.
- 예외: 컴포넌트 내부 여백이 필요한 경우 (예: 배경이 있는 Box 내부의 Text, 버튼 내부의 Text 등)에는 `padding` 사용 가능

## Drawable Resources
- SVG나 PNG를 그대로 가져다 쓸 때는 `Modifier.size()`를 설정하지 말아야 합니다.
- drawable 파일에 이미 정의된 크기를 그대로 사용해야 합니다.
- 예외: 특별한 경우에만 크기 조정이 필요할 수 있으나, 일반적으로는 원본 크기를 유지합니다.

## Example
```kotlin
@Composable
fun MyScreen(
    uiState: MyUiState,
    onButtonClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier) {
        // ...
    }
}

@Preview(showBackground = true)
@Composable
private fun MyScreenPreview() {
    AfternoteTheme {
        MyScreen(
            uiState = MyUiState(),
            onButtonClick = {}
        )
    }
}
```

---

# 2.5. Import Rules (임포트 규칙) - Critical

## Import Rules (임포트 규칙 - 중요)

### 1. Always Include Full Import Statements (항상 전체 임포트 문 포함)
- **ALWAYS include full import statements** for every class, function, and extension used in the code snippet.
  - *Reason*: Android Studio often fails to auto-import extension functions and Compose delegates.
  - 코드 스니펫에서 사용되는 모든 클래스, 함수, 확장 함수에 대해 항상 전체 임포트 문을 포함해야 합니다.
  - *이유*: Android Studio는 종종 확장 함수와 Compose delegate의 자동 임포트에 실패합니다.

### 2. Explicitly Import Extension Functions (확장 함수 명시적 임포트)
- **Never assume extension functions are globally available.** Always add the import line explicitly.
- 다음 확장 함수들은 자동 임포트되지 않으므로 명시적으로 임포트해야 합니다:
  - `androidx.core.view.isVisible` → `import androidx.core.view.isVisible`
  - `androidx.lifecycle.compose.collectAsStateWithLifecycle` → `import androidx.lifecycle.compose.collectAsStateWithLifecycle`
  - `androidx.compose.ui.platform.LocalContext` → `import androidx.compose.ui.platform.LocalContext`
  - `androidx.compose.ui.platform.LocalDensity` → `import androidx.compose.ui.platform.LocalDensity`
  - `androidx.compose.ui.platform.LocalFocusManager` → `import androidx.compose.ui.platform.LocalFocusManager`
  - *Instruction*: 이들이 전역적으로 사용 가능하다고 가정하지 마세요. 항상 명시적으로 임포트 라인을 추가하세요.

### 3. Jetpack Compose Imports (Jetpack Compose 임포트)
- **Always import `androidx.compose.runtime.*` delegates when using `by` keyword:**
  - `import androidx.compose.runtime.getValue`
  - `import androidx.compose.runtime.setValue`
  - `import androidx.compose.runtime.remember`
  - `by` 키워드를 사용할 때는 항상 `androidx.compose.runtime.*` delegate를 임포트해야 합니다.
- **Avoid wildcard imports** (e.g., `import androidx.compose.material3.*`) unless strictly necessary.
  - Use explicit imports to prevent `Unresolved Reference` errors.
  - 와일드카드 임포트를 피하고 명시적 임포트를 사용하여 `Unresolved Reference` 오류를 방지하세요.

### 4. Standard Import Rules (표준 임포트 규칙)
- **NEVER import `android.R`**: 절대 `android.R`을 임포트하지 마세요. 항상 애플리케이션 패키지의 `R` 클래스를 사용하세요 (예: `com.kuit.afternote.R`).
- **NO Wildcard Imports**: `import java.util.*` 같은 와일드카드 임포트를 사용하지 마세요. 명시적으로 특정 클래스를 임포트하세요.
- **Prefer AndroidX**: 항상 레거시 `android.support.*` 패키지보다 `androidx.*` 패키지를 선호하세요.

### 5. No Hallucinated Imports (환각 임포트 금지)
- **Do not invent extension functions** that do not exist in standard AndroidX libraries.
  - 표준 AndroidX 라이브러리에 존재하지 않는 확장 함수를 만들어내지 마세요.
- **Verify existence**: Before generating code, verify that all imported classes/functions exist in:
  - Standard Android SDK
  - Commonly used libraries (Hilt, Retrofit, Room, Compose, etc.)
  - 코드 생성 전에 모든 임포트된 클래스/함수가 다음에 존재하는지 확인하세요:
    * 표준 Android SDK
    * 일반적으로 사용되는 라이브러리 (Hilt, Retrofit, Room, Compose 등)

### 6. Generated Code Handling (생성된 코드 처리)
- **Hilt & ViewBinding**:
  - When referencing Hilt generated classes (`Hilt_MainActivity`), DO NOT import them manually.
  - Hilt 생성 클래스를 참조할 때는 수동으로 임포트하지 마세요.
  - For ViewBinding, ensure imports match the XML file name (e.g., `FragmentHomeBinding` for `fragment_home.xml`).
  - ViewBinding의 경우, 임포트가 XML 파일 이름과 일치하는지 확인하세요 (예: `fragment_home.xml` → `FragmentHomeBinding`).

### 7. Verification Step (검증 단계)
- **Before generating the final code block, double-check:**
  1. Are all `Modifier` extensions (padding, fillMaxSize, fillMaxWidth, etc.) imported?
     - 모든 `Modifier` 확장 함수가 임포트되었는가? (padding, fillMaxSize, fillMaxWidth 등)
  2. Are `getValue`/`setValue` imported for state delegates (`by remember { mutableStateOf() }`)?
     - 상태 delegate (`by remember { mutableStateOf() }`)를 사용할 때 `getValue`/`setValue`가 임포트되었는가?
  3. Are there any ambiguous imports (e.g., `android.R` vs `com.kuit.afternote.R`)?
     - 모호한 임포트가 있는가? (예: `android.R` vs `com.kuit.afternote.R`) → 앱의 R 클래스를 사용하세요.
  4. Are all Compose UI components properly imported?
     - 모든 Compose UI 컴포넌트가 제대로 임포트되었는가?
  5. Are extension functions from KTX libraries (fragment-ktx, activity-ktx) imported correctly?
     - KTX 라이브러리(fragment-ktx, activity-ktx)의 확장 함수가 올바르게 임포트되었는가?

## Kotlin & Compose Style
- 가능한 한 `var`보다 `val`을 사용하세요.
- Jetpack Compose에서 `Modifier` 체이닝 순서를 선호하세요: Size -> Layout -> Drawing -> Event Listeners.
- 기본적으로 Material3 디자인 시스템 컴포넌트를 사용하세요.
- Coroutines: ViewModel에서는 `viewModelScope`를, Fragments/Activities에서는 `LifecycleScope`를 사용하세요.

## Behavior
- 표준 라이브러리 솔루션이 존재하면, 지정되지 않은 한 3rd party 라이브러리보다 표준 라이브러리를 선호하세요.
- 오류를 수정할 때 임포트가 왜 잘못되었는지 설명하세요 (예: "사용하지 않는 임포트 제거").

---

# 3. Navigation Rules (네비게이션 규칙)

## Type-Safe Navigation
1. **Serializable Routes**: 모든 Route는 `kotlinx.serialization`의 `@Serializable` 어노테이션을 사용한 `sealed interface` 또는 `sealed class`로 정의합니다.
   - 문자열 하드코딩(예: "home/{id}")은 금지합니다.
   - 타입 안전한 네비게이션을 위해 sealed interface 또는 sealed class를 사용합니다.

2. **Domain Navigation (도메인 간 네비게이션)**
   - **다른 도메인으로 navigate 할 때는 인터페이스를 사용하세요.**
   - navgraph 내부에서 다른 도메인을 직접 아는 것은 지양합니다.
   - 도메인 간 의존성을 줄이고 모듈성을 유지하기 위해 인터페이스를 통해 네비게이션을 처리합니다.
   - 각 도메인은 자신의 Navigator 인터페이스를 정의하고, 구현체는 app 레벨에서 생성합니다.

## Navigation Example

```kotlin
// 1. core/navigation에 Navigator 인터페이스 정의 (다른 도메인으로 가는 메서드만)
interface OnboardingNavigator {
    fun goToMainPage(route: MainPageRoute)
}

interface MainPageNavigator {
    fun goToOnboarding(route: OnboardingRoute)
}

// 2. app/navigation/navigator에 구현체 생성
class OnboardingNavigatorImpl(
    private val navController: NavController
) : OnboardingNavigator {
    override fun goToMainPage(route: MainPageRoute) {
        navController.navigate(route)
    }
}

class MainPageNavigatorImpl(
    private val navController: NavController
) : MainPageNavigator {
    override fun goToOnboarding(route: OnboardingRoute) {
        navController.navigate(route)
    }
}

// 3. Route 정의 (@Serializable 필수)
sealed interface OnboardingRoute {
    @Serializable
    data object SplashRoute : OnboardingRoute
    
    @Serializable
    data object LoginRoute : OnboardingRoute
    // ...
}

sealed interface MainPageRoute {
    @Serializable
    data object MainEmptyRoute : MainPageRoute
    
    @Serializable
    data class DetailRoute(val id: Long) : MainPageRoute
    // ...
}

// 4. NavGraph에서 Navigator 구현체 생성 및 전달
@Composable
fun NavGraph(navHostController: NavHostController) {
    val onboardingNavigator = remember {
        OnboardingNavigatorImpl(navHostController)
    }
    val mainPageNavigator = remember {
        MainPageNavigatorImpl(navHostController)
    }
    
    NavHost(navController = navHostController, startDestination = "...") {
        onboardingNavGraph(navController, onboardingNavigator)
        mainPageNavGraph(navController, mainPageNavigator)
    }
}

// 5. 각 도메인 navgraph에서 Navigator 인터페이스 사용
fun NavGraphBuilder.onboardingNavGraph(
    navController: NavController,
    onboardingNavigator: OnboardingNavigator
) {
    composable<OnboardingRoute.SplashRoute> {
        // 같은 도메인 내부는 navController 직접 사용
        SplashScreen(
            onStartClick = { navController.navigate(OnboardingRoute.SignUpRoute) }
        )
    }
    
    // 다른 도메인으로 가는 경우 Navigator 인터페이스 사용
    // onboardingNavigator.goToMainPage(MainPageRoute.SomeRoute)
}
```

---

# 4. Dependency Injection Rules (Hilt 규칙)

1. **Constructor Injection**: 가능한 모든 클래스(`RepositoryImpl`, `UseCase`, `ViewModel`)는 생성자 주입(`@Inject constructor`)을 사용합니다.
2. **ViewModel**: `@HiltViewModel`을 사용하고, `SavedStateHandle`이 필요한 경우 생성자에 포함합니다.
3. **Modules**:
   - `Repository` 바인딩은 `@Binds`를 사용하여 추상화와 구현체를 연결합니다.
   - 외부 라이브러리(Retrofit, Room 등) 인스턴스는 `@Provides`를 사용합니다.
   - 모듈은 `di` 패키지 하위에 위치시킵니다.

## Example
```kotlin
@HiltViewModel
class MyViewModel @Inject constructor(
    private val myUseCase: MyUseCase
) : ViewModel() { ... }

@Module
@InstallIn(SingletonComponent::class)
abstract class DataModule {
    @Binds
    abstract fun bindMyRepository(
        impl: MyRepositoryImpl
    ): MyRepository
}
```

---

# 5. Code Quality & Formatting (코드 품질)

## Role & Goal
You are a Senior Android Developer with strict adherence to Kotlin coding standards and static analysis rules.
**Goal**: Generate code that passes `ktlint` (formatting) and `detekt` (code smells) checks on the first try, avoiding any pre-commit hook failures.

## Critical Instructions for Code Generation

### 1. Context & Config Awareness
- **Before generating code, briefly scan `.editorconfig` and `detekt.yml` in the project root** if they exist to understand custom indentations or max line lengths.
- If no config is found, default to **Standard Kotlin Style Guide**.

### 2. Ktlint Compliance (Formatting) - Critical

#### Import Rules
- **NO Wildcard Imports**: Never use `import foo.*`. Always import individual classes.
  - 예: `import androidx.compose.material3.*` ❌
  - 예: `import androidx.compose.material3.Text`, `import androidx.compose.material3.Button` ✅
- **Import Order**: Imports must be ordered in lexicographic order without any empty lines in-between with "java", "javax", "kotlin" and aliases in the end.

#### Formatting Rules
- **Indentation**: Use **4 spaces** for indentation. Do not use tabs.
- **Spacing**:
  - Put spaces around operators (`+`, `-`, `=`, etc.).
  - Put a space before `{` and after `if`, `for`, `while`.
  - Example: `if (condition) {` ✅, `if(condition){` ❌
- **Trailing Comma**: Use trailing commas in multi-line parameter lists or value arguments (if Kotlin version supports it).
- **Final Newline**: Ensure every file ends with a single newline character.
- **Blank Lines**: Limit consecutive blank lines to one.
- **Line Breaks**: Avoid unexpected newlines before `.` in chained calls. Keep chained modifiers on the same line or properly formatted.

#### Common Ktlint Violations to Avoid
- Unexpected newline before `.` in modifier chains
- Missing newline after `,` in multi-line parameter lists
- Unused imports (always remove unused imports)
- Import ordering violations

### 3. Detekt Compliance (Complexity & Smells) - Critical

#### Function Complexity
- **Function Length**: Keep functions short and focused (aim for < 20 lines). Break down complex logic into helper functions.
- **Max Line Length**: Limit lines to 120 characters (or 100 depending on your team's rule). Wrap long chained calls or parameters.
- **Long Parameter List**: Functions with more than 10 parameters should use data classes or be refactored.
  - Use `@Suppress("LongParameterList")` only when absolutely necessary and document why.

#### Code Smells
- **Magic Numbers**: Avoid hardcoded numbers. Extract them to `const val` or strict named constants, except for obvious values like 0, 1, or -1.
  - 예: `val timeout = 5000` ❌ → `const val TIMEOUT_MS = 5000` ✅
- **Nested Blocks**: Avoid deep nesting (max depth: 4). Use guard clauses (`return` early) to flatten `if-else` structures.
- **Empty Blocks**: Never leave `catch` or `if` blocks empty. Add a comment explaining why it's empty or handle the exception properly.
- **Top-Level Declarations**: Group constants, extension functions, and classes logically.

#### Detekt Rules
- **Detekt**: 프로젝트의 `detekt.yml` 규칙을 준수합니다.
  - 함수의 매개변수가 10개를 넘으면 data class로 묶거나 리팩토링을 고려합니다.
  - `Magic Number` 사용을 지양하고 상수로 정의합니다.
  - 함수 복잡도 제한을 준수합니다.

### 4. Pre-generation Checklist (코드 생성 전 필수 체크리스트)

**Before outputting the final code block, strictly verify:**

1. ✅ **Are there any wildcard imports?** (Remove them - this is the #1 ktlint violation)
2. ✅ **Is the indentation consistent (4 spaces)?**
3. ✅ **Are there any magic numbers inside the logic?** (Extract them to `const val`)
4. ✅ **Is any function too complex or long?** (Refactor into smaller functions)
5. ✅ **Are there any unused imports?** (Remove them)
6. ✅ **Is the import order correct?** (lexicographic order, java/javax/kotlin at the end)
7. ✅ **Are there unexpected newlines before `.` in modifier chains?** (Fix formatting)
8. ✅ **Does the file end with a single newline?** (Ensure it does)
9. ✅ **Are there any empty catch/if blocks?** (Add comments or proper handling)
10. ✅ **Are there any functions with > 10 parameters?** (Use data class or refactor)

### 5. Naming Convention
- Composable: `PascalCase` (예: `LoginScreen`)
- ViewModel: `PascalCase` + `ViewModel` (예: `LoginViewModel`)
- Repository/UseCase: `PascalCase` + `Repository`/`UseCase` (예: `LoginRepository`, `LoginUseCase`)
- Route: `PascalCase` + `Route` (예: `LoginRoute`)

## Output Format
- Provide clean, production-ready Kotlin code.
- Do not include comments like "// formatting fix" unless necessary for explanation.
- All code must pass ktlint and detekt checks on first commit attempt.

---

# 6. Resource Management (리소스 관리)

1. **Drawable**:
   - 아이콘은 `Icon` 컴포저블을 사용하고, `contentDescription`을 반드시 지정합니다.
   - 이미지 리소스 사용 시 `painterResource(R.drawable.name)`을 사용합니다.
   - Modifier로 사이즈를 강제하기보다, 벡터 리소스 자체의 크기를 유지하거나 `ContentScale`을 활용합니다.

2. **Strings**:
   - 모든 UI 텍스트는 `strings.xml`에 정의하여 사용합니다 (`stringResource(R.string.key)`).
   - 하드코딩된 문자열은 금지합니다.

---

# 7. Testing Rules (테스트 규칙)

1. **Unit Test**:
   - `Domain Layer`(`UseCase`)와 `ViewModel`은 100%에 가까운 테스트 커버리지를 지향합니다.
   - `MockK`를 사용하여 의존성을 모킹합니다.

2. **Naming**:
   - 테스트 함수명은 행위를 명확히 기술합니다 (예: `fetchUser_whenSuccess_returnsUser`).

---

# 8. Git & Commit Rules (커밋 규칙)

## Conventional Commits
커밋 메시지는 아래 형식을 따릅니다:
`type(scope): subject`

- **Types**:
  - `feat`: 새로운 기능 추가
  - `fix`: 버그 수정
  - `refactor`: 코드 리팩토링 (기능 변경 없음)
  - `style`: 포맷팅, 세미콜론 누락 등 (코드 변경 없음)
  - `docs`: 문서 수정
  - `test`: 테스트 추가/수정
  - `chore`: 빌드 태스크, 패키지 매니저 설정 등
  - `build`: 빌드 시스템 또는 외부 종속성 변경
  - `ci`: CI 설정 파일 및 스크립트 변경
  - `perf`: 성능 개선

## Example
- `feat(auth): add login usecase`
- `fix(ui): correct padding in home screen`
- `refactor(navigation): apply navigator pattern`

---

# 9. Documentation (문서화)

1. **Public API**: `public` 함수나 클래스(특히 `UseCase`, `Repository` 인터페이스)에는 KDoc을 작성하여 역할과 파라미터를 설명합니다.

2. **Complex Logic**: 복잡한 비즈니스 로직이 들어가는 곳에는 주석을 통해 '왜(Why)' 이렇게 구현했는지 설명합니다.

3. **README 업데이트**: 파일을 변경할 때마다 README 변경이 필요한지 체크하고, 필요하면 반드시 변경해야 합니다.

## Example
```kotlin
/**
 * 사용자의 로그인 상태를 확인하고, 토큰을 갱신합니다.
 *
 * @param forceRefresh 강제로 토큰을 갱신할지 여부
 * @return 갱신된 토큰 정보
 */
suspend fun checkAuth(forceRefresh: Boolean): AuthToken
```

---

# 10. Test Code Verification (테스트 코드 확인 규칙) - Critical

## 코드 변경 시 테스트 디렉토리 확인 및 테스트 코드 추가

코드를 생성하거나 수정할 때마다 **반드시** 다음을 확인하고 필요하면 테스트 코드를 추가해야 합니다:

### 1. 테스트 디렉토리 확인
- `app/src/test/java/com/kuit/afternote/` (Unit Test)
- `app/src/androidTest/java/com/kuit/afternote/` (Instrumented Test)

### 2. 테스트 코드 추가가 필요한 경우

다음과 같은 코드 변경 시 해당하는 테스트 디렉토리에 테스트 코드를 추가해야 합니다:

#### UseCase 추가/수정 시
- **위치**: `app/src/test/java/com/kuit/afternote/feature/{feature_name}/domain/usecase/`
- **파일명**: `{UseCaseName}Test.kt`
- **내용**: UseCase의 모든 메서드에 대한 단위 테스트 작성
- **예시**: `LoginUseCase` 추가 시 → `LoginUseCaseTest.kt` 생성

#### ViewModel 추가/수정 시
- **위치**: `app/src/test/java/com/kuit/afternote/feature/{feature_name}/presentation/viewmodel/`
- **파일명**: `{ViewModelName}Test.kt`
- **내용**: ViewModel의 상태 변경, 이벤트 처리에 대한 단위 테스트 작성
- **예시**: `LoginViewModel` 추가 시 → `LoginViewModelTest.kt` 생성

#### Repository Interface 추가/수정 시
- **위치**: `app/src/test/java/com/kuit/afternote/feature/{feature_name}/domain/repository/`
- **파일명**: `{RepositoryName}Test.kt` (인터페이스 테스트는 선택적)
- **참고**: Repository 구현체(`Impl`)는 Data Layer이므로 실제 구현에 따라 테스트 작성

#### 복잡한 비즈니스 로직 추가 시
- Domain Layer의 복잡한 로직이 있는 경우 단위 테스트 작성
- 유틸리티 함수나 헬퍼 클래스 추가 시 테스트 작성

### 3. 테스트 코드 작성 규칙

#### 테스트 파일 구조
```kotlin
package com.kuit.afternote.feature.{feature_name}.domain.usecase

import org.junit.Test
import org.junit.Assert.*
// ... 필요한 임포트

class {UseCaseName}Test {
    
    @Test
    fun `methodName_whenCondition_returnsExpectedResult`() {
        // Given
        // When
        // Then
    }
}
```

#### 테스트 네이밍 규칙
- 테스트 함수명: `methodName_whenCondition_returnsExpectedResult` 형식
- 예시: `login_whenSuccess_returnsUser()`, `login_whenInvalidCredentials_throwsException()`

#### 테스트 작성 시 주의사항
- MockK를 사용하여 의존성을 모킹합니다
- Given-When-Then 패턴을 사용합니다
- 모든 엣지 케이스를 테스트합니다

### 4. 확인 절차

코드 변경 후 다음을 확인:

1. **UseCase/ViewModel 추가 여부 확인**
   - 추가했다면 → 해당 테스트 디렉토리에 테스트 파일이 있는지 확인
   - 없으면 → 테스트 파일 생성 및 테스트 코드 작성

2. **기존 테스트 파일 확인**
   - 수정한 코드에 해당하는 기존 테스트 파일이 있는지 확인
   - 있으면 → 수정된 코드에 맞게 테스트 업데이트 필요 여부 확인

3. **테스트 실행 가능 여부 확인**
   - 작성한 테스트가 컴파일되는지 확인
   - 테스트가 실제로 실행 가능한지 확인

### 5. 예외 사항

다음의 경우는 테스트 코드 작성이 선택적입니다:
- 단순한 data class나 enum 추가
- UI 컴포넌트만 추가 (Composable 함수)
- 단순한 확장 함수 추가
- 설정 파일이나 상수만 추가

---

# 11. Branch Workflow Rules (브랜치 작업 규칙)

## 기본 원칙

**변경사항은 항상 주제에 맞는 브랜치에서 작업해야 합니다.**

### 규칙

1. **현재 브랜치의 주제와 맞지 않는 변경사항은 별도 브랜치 생성**
   - 예: `feat/afternote` 브랜치에서 작업 중인데 문서 수정이 필요한 경우
   - → `docs/update-readme` 같은 별도 브랜치 생성

2. **브랜치 네이밍 규칙**
   - `feat/`: 새로운 기능
   - `fix/`: 버그 수정
   - `docs/`: 문서 수정
   - `chore/`: 기타 작업 (설정, 도구 등)
   - `refactor/`: 리팩토링

3. **작업 흐름**
   ```
   현재 브랜치에서 작업 중
   → 주제와 맞지 않는 변경 필요
   → 새 브랜치 생성 (주제에 맞는 이름)
   → 변경사항 커밋
   → 메인에 병합
   → 원래 브랜치로 돌아가서 메인 병합
   ```

4. **구현 요구 시 브랜치 생성 규칙**
   - 사용자가 구현을 요구할 때마다 해당 구현에 적절한 이름의 브랜치를 생성하고 체크아웃한 다음 작업해야 합니다
   - 브랜치 이름은 작업 내용을 명확히 나타내야 합니다
   - 예: `feat/add-custom-radio-button`, `fix/text-field-padding`, `refactor/move-component-to-core`
   - 작업 완료 후 해당 브랜치에서 커밋하고, 필요시 메인에 병합합니다

5. **자동 병합 규칙 (Auto Merge Rules)**
   - **푸시 후 자동 병합 판단**: 작업을 푸시한 후 다음 조건을 확인하여 메인에 병합이 필요한지 판단합니다:
     * 작업이 완료되었고 테스트가 통과한 경우
     * 다른 브랜치와의 충돌이 없는 경우
     * 코드 리뷰가 필요 없는 간단한 변경인 경우 (설정 파일, 문서, 작은 버그 수정 등)
   - **자동 병합 실행**: 위 조건을 만족하면 자동으로 메인 브랜치에 병합합니다.
     * `git checkout main` 또는 `git checkout master`
     * `git merge {작업_브랜치}` 또는 `git merge --no-ff {작업_브랜치}`
     * `git push origin main` 또는 `git push origin master`
   - **병합 불필요한 경우**: 다음의 경우는 자동 병합하지 않습니다:
     * 큰 기능 추가나 리팩토링 (코드 리뷰 필요)
     * 다른 팀원과 협의가 필요한 변경
     * 사용자가 명시적으로 병합하지 말라고 한 경우

6. **예외 상황**
   - 현재 브랜치의 주제와 직접 관련된 변경은 현재 브랜치에서 작업 가능
   - 긴급한 버그 수정은 별도 브랜치 생성 후 메인에 병합

## 예시

### ❌ 잘못된 예
- `feat/afternote` 브랜치에서 README 수정 커밋
- `feat/afternote` 브랜치에서 Gradle 설정 변경 커밋

### ✅ 올바른 예
- README 수정 → `docs/update-readme` 브랜치 생성
- Gradle 설정 변경 → `chore/update-gradle-config` 브랜치 생성
- 각각 메인에 병합 후 `feat/afternote`에 반영

---

# 12. General Guidelines (일반 작업 가이드라인)

## 기본 원칙

1. **주제에 맞는 브랜치에서 작업**
   - 자세한 내용은 Branch Workflow Rules 참고

2. **시도한 해결책 메모**
   - 문제 해결 시 시도한 방법들을 메모해두기
   - 같은 실수를 반복하지 않기 위함

3. **문서화**
   - 중요한 설정이나 해결 방법은 문서로 남기기
   - 다른 팀원이나 미래의 자신을 위해

4. **컴포넌트 프리뷰 필수**
   - 모든 컴포넌트 함수는 반드시 `@Preview` 어노테이션을 사용한 프리뷰 함수를 포함해야 합니다
   - 프리뷰는 컴포넌트의 다양한 상태를 보여주는 것이 좋습니다 (선택됨/선택 안 됨, 활성화/비활성화 등)
   - 예외: 내부 전용 컴포넌트(`internal` 함수)는 선택적으로 작성 가능

5. **Compose 컴포넌트 파일 구조 규칙**
   - 각 파일에는 하나의 `@Composable` 함수와 그에 해당하는 하나의 `@Preview` 함수만 포함해야 합니다
   - 예외: data class나 enum 등은 같은 파일에 포함 가능하거나 별도 파일로 분리 가능
   - 여러 컴포넌트가 필요한 경우 각각 별도 파일로 분리해야 합니다

6. **Drawable 리소스 사용 규칙**
   - SVG나 PNG를 그대로 가져다 쓸 때는 `Modifier.size()`를 설정하지 말아야 합니다
   - drawable 파일에 이미 정의된 크기를 그대로 사용해야 합니다
   - 예외: 특별한 경우에만 크기 조정이 필요할 수 있으나, 일반적으로는 원본 크기를 유지합니다

7. **컴포넌트 간 간격 처리 일관성 규칙**
   - 특정 컴포넌트(예: Text)에만 `padding`을 사용하여 다음 컴포넌트와의 간격을 처리하지 말아야 합니다
   - 모든 컴포넌트에 일관되게 간격 처리 방법을 적용해야 합니다
   - 예외: 컴포넌트 내부 여백이 필요한 경우 (예: 배경이 있는 Box 내부의 Text, 버튼 내부의 Text 등)에는 `padding` 사용 가능

## 작업 전 체크리스트

- [ ] 현재 브랜치가 작업 주제와 맞는가?
- [ ] 별도 브랜치가 필요한가?
- [ ] 이전에 시도한 방법이 있는가? (문서 확인)
- [ ] 변경사항을 문서화해야 하는가?
- [ ] README에 변경이 필요한 내용이 있는가?

## 파일 변경 시 README 체크 규칙

**파일을 변경할 때마다 README 변경이 필요한지 체크하고, 필요하면 반드시 변경해야 합니다.**

### 체크해야 할 경우

1. **새로운 설정이나 도구 추가**
   - 예: 새로운 라이브러리, 빌드 도구, 개발 환경 설정
   - README의 설정 섹션 업데이트 필요

2. **프로젝트 구조 변경**
   - 예: 폴더 구조 변경, 새로운 모듈 추가
   - README의 프로젝트 구조 설명 업데이트

3. **개발 환경 요구사항 변경**
   - 예: JDK 버전 변경, 새로운 의존성 추가
   - README의 필수 요구사항 섹션 업데이트

4. **빌드/실행 방법 변경**
   - 예: 새로운 빌드 스크립트, 실행 방법 변경
   - README의 빌드/실행 가이드 업데이트

5. **트러블슈팅 정보 추가**
   - 예: 새로운 에러 해결 방법 발견
   - README의 트러블슈팅 섹션에 추가

6. **워크플로우나 규칙 변경**
   - 예: 브랜치 전략 변경, 커밋 규칙 변경
   - README의 관련 섹션 업데이트

### 체크 방법

파일 변경 후 다음을 확인:
1. 이 변경이 다른 개발자에게 영향을 주는가?
2. 이 변경을 이해하기 위해 문서가 필요한가?
3. 이 변경으로 인해 기존 README 내용이 부정확해졌는가?

**모든 답변이 "아니오"가 아니라면 README를 업데이트해야 합니다.**
