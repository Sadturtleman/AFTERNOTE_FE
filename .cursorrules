# ⚠️ CRITICAL RULES SUMMARY (핵심 규칙 요약) - READ FIRST

**이 섹션은 AI가 가장 먼저 인식해야 하는 핵심 규칙입니다. 상세 설명은 `.cursor/rules/*.mdc` 파일들을 참조하세요.**

## MUST DO (반드시 수행)
1. **Git**: 사용자 명시적 요청 없이 절대 커밋/푸시 금지
   - **검증 절차**: 푸시 명령 생성 전, 현재 브랜치가 `main`/`develop`이 아닌지 **반드시 먼저 검증** (`git branch --show-current`)
   - **조건부 긍정문**: "하지 마라" 대신 "검증 절차를 먼저 수행하라"로 표현
2. **Branch**: 작업 전 반드시 적절한 브랜치 확인/생성 (`feat/`, `fix/`, `docs/` 등)
3. **Branch Cleanup**: 푸시 완료 후 main에 병합된 로컬 브랜치 자동 삭제
4. **Merge Strategy (병합 전략) - Critical**: 사용자가 "메인에 병합해" 또는 "메인과 병합해"라고 요청한 경우:
   - **1단계**: 현재 브랜치에 원격 main의 최신 변경사항을 먼저 가져와서 병합 (`git fetch origin main && git merge origin/main`)
   - **2단계**: 충돌이 있으면 해결하고, 빌드 확인은 사용자가 명시적으로 요청한 경우에만 실행 (`./gradlew :app:compileDebugKotlin`)
   - **3단계**: 문제가 없을 때만 main 브랜치로 체크아웃하여 현재 브랜치를 병합 (`git checkout main && git merge {현재브랜치}`)
   - **4단계**: main 브랜치에 푸시 (`git push origin main`)
   - **원칙**: "먼저 현재 브랜치에 main을 병합하고, 문제 없을 때만 main에 반영"
4. **Preview**: 모든 public Composable에 `@Preview` 필수
5. **Import**: 전체 import 문 포함, 확장 함수 명시적 import, 와일드카드 금지
6. **Modifier**: 모든 Composable 첫 파라미터 `modifier: Modifier = Modifier`
7. **State**: 상태는 호출부로 hoisting, Stateless composable 지향
   - **완전한 State Hoisting**: 화면 내부의 모든 상태(탭, 네비게이션 등)는 ViewModel로 이동
8. **Architecture**: Presentation → Domain ← Data (엄격한 계층 분리)
9. **Error Handling**: 3회 이상 실패 시 중단하고 Perplexity 프롬프트 제공
10. **ViewModel 주입**: `androidx.lifecycle.viewmodel.compose.viewModel()` 사용 (절대 `hiltViewModel()` 사용 금지)
11. **StateFlow 수집**: `collectAsStateWithLifecycle()` 사용 (절대 `collectAsState()` 사용 금지)
12. **`.cursorrules` 관리**: 이 파일이 300줄을 초과하면 분리 또는 핵심 규칙만 남기는 리팩토링 고려
13. **Named Arguments 필수**: 함수 호출 시 파라미터 이름 명시 (아래 조건 해당 시)
   - 인자가 3개 이상인 경우
   - Boolean, Null, 숫자 리터럴이 포함된 경우
   - 같은 타입의 인자가 연속되는 경우
   - Compose 함수 호출 시 (modifier 제외한 모든 인자)
   - 예: `Recipient(id = "1", name = "김지은", label = "친구")`, `FontWeight.Medium` (NOT `FontWeight(500)`)

## MUST NOT DO (절대 금지)
1. 커밋/푸시 자동 실행
2. **빌드 자동 실행**: 사용자가 명시적으로 요청하지 않으면 빌드(`./gradlew`, `gradle build` 등)를 자동으로 실행하지 않음. Android Studio와 동시 사용 시 파일 잠금 문제가 발생할 수 있음. 빌드가 필요한 경우 사용자에게 요청하거나, 사용자가 명시적으로 "빌드해", "build", "컴파일 확인해" 등을 요청한 경우에만 실행
3. `android.R` import
4. 와일드카드 import (`import foo.*`)
5. Domain Layer에 Android/Data 의존성
6. 설명 없이 코드만 생성 (사용자 요청 시 제외)
7. **Sycophancy (아첨)**: 사용자가 답변을 질문하거나 반문할 때, 즉시 사과하거나 답변을 변경하지 말 것. 먼저 자신의 논리를 설명하고, 사실적으로 틀렸을 때만 사과할 것.
8. **Ask Mode에서 파일 수정 시도**: Ask 모드에서는 STRICTLY ANSWER ONLY. 파일 수정을 시도하지 말 것. 질문은 순수한 궁금증으로 해석하고, 지적이나 수정 요구로 해석하지 말 것.
9. **Deprecated API 사용**: `androidx.hilt.navigation.compose.hiltViewModel()` 사용 금지
10. **비 Lifecycle-aware State 수집**: `collectAsState()` 사용 금지 (메모리 누수 위험)
11. **로컬 상태 관리**: Composable 내부에서 `remember { mutableStateOf() }`로 화면 상태 관리 금지 (ViewModel로 이동)

## CRITICAL PATTERNS (핵심 패턴)
- **Named Arguments Pattern**: 가독성과 안전성을 위해 명시적 파라미터 이름 사용. `FontWeight(500)` 대신 `FontWeight.Medium` 사용. 계산식(`Spacing.l - 8.dp`) 금지
- **Rem-based Design**: 큰 간격(24dp+)은 `weight`과 `Arrangement`, 작은 간격(8dp 이하)은 `Spacer`, 컴포넌트 크기는 항상 고정 dp
- **Padding 지양, Spacer 사용**: 컴포넌트에 `Modifier.padding()` 직접 적용 금지. 간격은 `Spacer`로 표현. 화면 가장자리 padding만 예외
- **Core 컴포넌트 최대한 활용**: `core` 모듈의 공통 컴포넌트(`Header`, `LabeledTextField`, `MessageTextField`, `CustomRadioButton` 등)를 최대한 재사용
- **컴포넌트 오버로딩**: 전체 틀은 비슷하고 세부 디자인만 다른 경우, 별도 컴포넌트 대신 **오버로딩**으로 처리
- **큰 간격 처리**: padding 값이 큰 경우(24dp 이상) `Spacer(Modifier.weight())` 또는 `Arrangement.SpaceBetween` 등으로 해결
- **Component Reuse**: 불확실하면 `private` 함수로, 재사용 확정되면 별도 파일
- **File Limit**: 400줄 초과 시 분리, 폴더당 10-15개 파일 유지
- **`.cursorrules` 최적화**: 300줄 이하 권장, 초과 시 `.cursor/rules/*.mdc`로 분리 고려
- **Tests**: UseCase/ViewModel 변경 시 테스트 확인/추가
- **Parameter Refactoring Pattern**: 10개 이상 파라미터가 필요한 경우, 단순히 data class로 묶지 말고 **섹션별 그룹화** 패턴 적용
- **State Holder Pattern for Cognitive Complexity**: SonarQube 인지 복잡도 15 이하를 위해 **State Holder 패턴** 필수 적용. Composable 내부 람다 정의 금지, 모든 로직은 State 클래스로 이동
- **Slot API Pattern (Composition over Inheritance)**: 유사한 구조를 가진 컴포넌트들을 통일할 때는 **상속이 아닌 합성(Composition)**을 사용. 공통 껍데기를 제공하고 내용물은 Slot(`content: @Composable () -> Unit`)으로 주입받는 방식
- **Component Location Rules (컴포넌트 위치 결정 규칙)**: 공통 컴포넌트는 반드시 `core` 모듈에 위치해야 함. Feature 모듈 간 직접 의존은 금지되며, 공통 컴포넌트는 `core`에 두어야 함
- **@Suppress 사용 전 코드 구조 개선 필수**: detekt 경고 발생 시 `@Suppress`를 사용하기 전에 반드시 코드 구조 개선을 시도해야 함. State Hoisting 패턴 적용 후 파라미터가 많아지면 Event Interface나 State Class로 그룹화하여 해결
- **구조 변경 시 필수 검증**: 파일 이동, 패키지 변경, 클래스 리팩토링 시 변경 전/후 빌드 확인, 사용처 전체 검색, import 경로 일괄 변경 필수
- **Spacing Grouping Pattern**: `Arrangement.spacedBy`와 `Spacer` 혼용 시 계산식 금지. 간격이 다른 요소는 별도 `Column`으로 그룹화

---

# Project Context
- **Project Type**: Android App (Kotlin, Jetpack Compose)
- **Architecture**: Clean Architecture (Data, Domain, Presentation Layers)
- **Dependency Injection**: Hilt
- **Navigation**: Navigation Compose (Type-safe with kotlinx.serialization)
- **Code Quality**: Detekt
- **JDK**: JDK 21 (Eclipse Adoptium)

---

# 규칙 파일 구조

이 프로젝트는 `.cursor/rules/*.mdc` 파일 구조를 사용하여 규칙을 분리합니다:

- **`.cursor/rules/workflow/git-policy.mdc`**: Git 작업 및 브랜치 관리 정책 (항상 적용: `alwaysApply: true`)
- **`.cursor/rules/workflow/branch-workflow.mdc`**: 브랜치 작업 및 워크플로우 규칙 (항상 적용: `alwaysApply: true`)
- **`.cursor/rules/tech-stack/architecture.mdc`**: Clean Architecture 및 계층 분리 규칙
- **`.cursor/rules/tech-stack/compose.mdc`**: Jetpack Compose 코딩 규칙 및 패턴
- **`.cursor/rules/tech-stack/android-kotlin.mdc`**: Android/Kotlin 코딩 컨벤션 및 Import 규칙
- **`.cursor/rules/quality/code-quality.mdc`**: 코드 품질, 포맷팅, 테스트 규칙

각 `.mdc` 파일은 `globs` 패턴을 사용하여 관련 파일을 열거나 작업할 때만 해당 규칙이 주입됩니다.
**워크플로우 규칙(Git, 브랜치)은 모든 파일에서 적용되므로 `alwaysApply: true`로 설정되어 있습니다.**

## 물리적 제어 (Hard Constraint)
- **Git Hook**: `scripts/pre-push-check.sh` 스크립트를 Git Hook으로 설정하여 main/develop 브랜치 직접 푸시를 시스템 레벨에서 차단합니다.
  - 설정: `cp scripts/pre-push-check.sh .git/hooks/pre-push && chmod +x .git/hooks/pre-push`

---

# General Guidelines (일반 작업 가이드라인)

## 기본 원칙

1. **Sycophancy 방지 (아첨 금지) - Critical**
   - 사용자가 답변을 질문하거나 반문할 때, 즉시 사과하거나 답변을 변경하지 말 것
   - 먼저 자신의 논리와 근거를 설명할 것
   - 사실적으로 틀렸을 때만 사과할 것

2. **Ask Mode 전용 규칙 - Critical**
   - **STRICTLY ANSWER ONLY**: Ask 모드에서는 파일 수정을 절대 시도하지 말 것
   - **질문 해석**: 사용자의 질문은 순수한 궁금증(PURE CURIOSITY)으로 해석할 것. 지적이나 수정 요구로 해석하지 말 것
   - **사과 금지**: Ask 모드에서 이전 코드에 대해 사과하지 말 것. 명시적으로 틀렸다고 증명되지 않는 한
   - **논리 설명**: 질문에 대해 논리를 차분히 설명할 것

3. **주제에 맞는 브랜치에서 작업**
   - 자세한 내용은 `.cursor/rules/workflow/branch-workflow.mdc` 참고

4. **`.cursorrules` 파일 작성 규칙**
   - **최상단에 Critical Rules Summary 필수**: `.cursorrules` 파일을 작성하거나 수정할 때는 반드시 최상단에 "⚠️ CRITICAL RULES SUMMARY" 섹션을 포함해야 합니다.
   - **Summary 구조**:
     * MUST DO (반드시 수행): 핵심 규칙을 간결하게 나열
     * MUST NOT DO (절대 금지): 금지 사항을 명확히 표시
     * CRITICAL PATTERNS (핵심 패턴): 중요한 패턴 요약
   - **목적**: AI가 Context Window 초반부에서 핵심 규칙을 먼저 인식하도록 하여 규칙 무시나 환각을 방지합니다.

5. **시도한 해결책 메모**
   - 문제 해결 시 시도한 방법들을 메모해두기
   - 같은 실수를 반복하지 않기 위함

6. **문서화**
   - 중요한 설정이나 해결 방법은 문서로 남기기
   - 다른 팀원이나 미래의 자신을 위해

7. **컴포넌트 프리뷰 필수**
   - 모든 컴포넌트 함수는 반드시 `@Preview` 어노테이션을 사용한 프리뷰 함수를 포함해야 합니다
   - 프리뷰는 컴포넌트의 다양한 상태를 보여주는 것이 좋습니다 (선택됨/선택 안 됨, 활성화/비활성화 등)
   - 예외: 내부 전용 컴포넌트(`internal` 함수)는 선택적으로 작성 가능

## 파일 변경 시 README 체크 규칙

**파일을 변경할 때마다 README 변경이 필요한지 체크하고, 필요하면 반드시 변경해야 합니다.**

### 체크해야 할 경우
1. 새로운 설정이나 도구 추가
2. 프로젝트 구조 변경
3. 개발 환경 요구사항 변경
4. 빌드/실행 방법 변경
5. 트러블슈팅 정보 추가
6. 워크플로우나 규칙 변경

**모든 답변이 "아니오"가 아니라면 README를 업데이트해야 합니다.**

## Problem Solving & Research Rules (문제 해결 및 조사 규칙)

### ⚠️ Critical: 작업 중단 및 조사 규칙

**작업 중 문제가 발생하거나 막히는 경우, 즉시 중단하고 Perplexity 프롬프트를 제공해야 합니다.**

### 작업 중단 조건
1. 예상치 못한 오류 발생
2. API 또는 라이브러리 사용법 불확실
3. 시각적 문제 발생
4. 3회 이상 시도 실패

### ⚠️ Critical: 구조 변경 시 필수 검증 절차
**파일 이동, 패키지 변경, 클래스 리팩토링 등 구조적 변경 작업 시 반드시 다음 절차를 따라야 합니다:**

1. **변경 전 빌드 확인**: 구조 변경 전에 현재 상태가 빌드되는지 확인 (`./gradlew :app:compileDebugKotlin`) - **단, 사용자가 명시적으로 요청한 경우에만 실행**
2. **사용처 전체 검색**: 이동/변경할 파일이 사용되는 모든 위치를 `grep`으로 검색하여 리스트업
3. **Import 경로 일괄 변경**: 모든 사용처의 import 경로를 한 번에 변경 (단계적으로 하지 말고 전체를 먼저 파악)
4. **변수/함수명 변경 시**: 변수명이나 함수명을 변경할 때는 `grep`으로 모든 사용처 확인 후 일괄 변경
5. **변경 후 빌드 검증**: 파일 이동/변경 후 빌드가 필요한 경우 사용자에게 요청하거나, 사용자가 명시적으로 요청한 경우에만 실행 (`./gradlew :app:compileDebugKotlin`)
6. **State/Params 클래스 이동 시**: State 클래스나 Params 클래스를 이동할 때는 해당 클래스를 사용하는 모든 컴포넌트의 import 경로를 확인
7. **중복 제거 시**: 중복 파일을 제거하기 전에 사용처를 모두 확인하고, 하나로 통합한 후 모든 import 경로를 업데이트

### ⚠️ Critical: macOS Git Index 권한 문제 해결
**macOS에서 `fatal: .git/index: index file open failed: Operation not permitted` 오류가 발생하는 경우:**

1. **즉시 해결 방법**: Git 명령 실행 전에 항상 `.git/index` 파일 권한을 설정합니다.
   ```bash
   chmod 666 .git/index && <git 명령어>
   ```
   예: `chmod 666 .git/index && git status`
   예: `chmod 666 .git/index && git add .`
   예: `chmod 666 .git/index && git commit -m "message"`

2. **근본 원인**: macOS의 보안 정책(TCC)이나 확장 속성(xattr) 충돌로 인해 발생합니다. `chmod 666`으로 권한을 설정하면 읽기/쓰기가 가능해집니다.

3. **주의사항**: 
   - Git 명령 실행 시마다 권한 설정이 필요할 수 있습니다.
   - `required_permissions: ['all']`을 사용하여 sandbox 제한을 우회할 수 있습니다.
   - 문제가 지속되면 사용자에게 터미널에서 직접 실행하도록 안내합니다.

4. **반복 방지**: Git 관련 명령을 실행할 때는 먼저 `.git/index` 파일 권한을 확인하고, 필요시 `chmod 666 .git/index`를 실행한 후 Git 명령을 실행합니다.

### ⚠️ Critical: GitHub 인증 및 PR 작업 시 필수 사항
**GitHub CLI (`gh`) 명령 실행 시 인증 오류가 발생하는 경우:**

1. **항상 `required_permissions: ['all']` 사용**: GitHub 관련 작업(PR 생성, 병합, 인증 등)은 반드시 `required_permissions: ['all']`을 사용하여 sandbox 제한을 우회합니다.

2. **GitHub CLI 인증 확인 및 설정**:
   ```bash
   gh auth status  # 인증 상태 확인
   gh auth login   # 인증이 안 되어 있으면 로그인
   ```
   - 인증은 한 번만 하면 계속 사용 가능합니다.
   - `gh auth login` 실행 시 웹 브라우저에서 인증이 완료됩니다.

3. **Git push 인증 문제 해결**:
   - `fatal: could not read Username for 'https://github.com': Device not configured` 오류 발생 시
   - `required_permissions: ['all']`을 사용하면 저장된 인증 정보에 접근 가능합니다.
   - Git credential helper(`osxkeychain`)가 설정되어 있으면 자동으로 사용됩니다.

4. **PR 생성 및 병합**:
   - PR 생성: `gh pr create --title "..." --body "..." --base main`
   - PR 병합: `gh pr merge <PR_NUMBER> --merge --delete-branch`
   - 모든 GitHub CLI 명령은 `required_permissions: ['all']`과 함께 실행합니다.

5. **반복 방지**: 
   - GitHub 관련 작업은 항상 `required_permissions: ['all']`을 사용합니다.
   - 인증 오류 발생 시 먼저 `gh auth status`로 확인하고, 필요시 `gh auth login`을 실행합니다.
   - 사용자에게 "터미널에서 직접 실행하세요"라고 안내하지 말고, 제가 직접 해결합니다.

### Perplexity 프롬프트 작성 요청 시 규칙 - Critical
**사용자가 "퍼플렉시티 프롬프트 작성해" 또는 "Perplexity 프롬프트 작성해"라고 명시적으로 요청한 경우:**
- **프롬프트 내용만 제공**: 프롬프트에 붙여 넣을 내용 외에는 아무 말도 하지 않습니다.
- **추가 설명 금지**: 프롬프트 작성 후 "이 프롬프트를 Perplexity에 붙여넣으세요" 같은 안내 문구도 포함하지 않습니다.
- **코드 수정 금지**: 프롬프트 작성과 동시에 코드를 수정하지 않습니다.
- **형식**: 프롬프트는 마크다운 코드 블록 없이 순수 텍스트로 제공합니다 (사용자가 바로 복사-붙여넣기 할 수 있도록).

---

# ⚠️ CRITICAL RULES 재확인 (파일 끝 - 샌드위치 기법)

**이 파일을 읽을 때 반드시 위의 핵심 규칙을 재확인하시오:**

## 최우선 규칙 (절대 무시 금지)
1. **Git 작업 전 검증**: 커밋/푸시 명령 생성 전, 현재 브랜치가 `main`/`develop`이 아닌지 **반드시 먼저 검증**
2. **사용자 명시적 요청 없이 절대 커밋/푸시 금지**
3. **`.cursorrules` 길이 관리**: 이 파일이 300줄을 초과하면 분리 또는 핵심 규칙만 남기는 리팩토링 고려

## 핵심 기술 규칙
- **ViewModel 주입**: `viewModel()` 사용 (절대 `hiltViewModel()` 사용 금지)
- **StateFlow 수집**: `collectAsStateWithLifecycle()` 사용 (절대 `collectAsState()` 사용 금지)
- **State Hoisting**: 모든 화면 상태는 ViewModel로 이동
- **Preview 필수**: 모든 public Composable에 `@Preview` 필수

## 규칙 파일 참조
- 세부 규칙은 `.cursor/rules/*.mdc` 파일들을 참조하세요.
- 각 파일은 `globs` 패턴을 사용하여 관련 작업 시 자동으로 주입됩니다.

**위 규칙들을 위반하면 심각한 문제가 발생할 수 있습니다. 반드시 준수하시오.**
