# Project Context
- **Project Type**: Android App (Kotlin, Jetpack Compose)
- **Architecture**: Clean Architecture (Data, Domain, Presentation Layers)
- **Dependency Injection**: Hilt
- **Navigation**: Navigation Compose (Type-safe with kotlinx.serialization)
- **Code Quality**: Detekt
- **JDK**: JDK 21 (Eclipse Adoptium)

---

# 1. Architecture Rules (아키텍처 규칙)

## Layer Separation (계층 분리)
모든 Feature 모듈은 아래 3계층을 엄격히 준수해야 합니다.

1. **Domain Layer** (Pure Kotlin)
   - 외부 의존성(Android Framework, Data Layer 등)을 가지지 않습니다.
   - `Entity`, `Repository Interface`, `UseCase`가 위치합니다.
   - 비즈니스 로직의 핵심입니다.

2. **Data Layer**
   - Domain Layer의 `Repository`를 구현(`Impl`)합니다.
   - API 호출, DB 접근, DTO 매핑을 담당합니다.
   - `Mapper`를 통해 DTO를 Domain Entity로 변환하여 반환합니다.

3. **Presentation Layer**
   - UI (`Screen`, `Component`)와 상태 관리 (`ViewModel`)를 담당합니다.
   - Domain Layer의 `UseCase`를 주입받아 비즈니스 로직을 수행합니다.
   - `UiModel`을 정의하여 UI에 필요한 데이터만 가공해 보여줍니다.

## Dependency Flow (의존성 방향)
- **Correct**: Presentation → Domain ← Data
- **Incorrect**: Domain → Data (X), Domain → Presentation (X)

---

# 2. Jetpack Compose Rules (Compose 규칙)

## Composable Functions
1. **State Hoisting**: 상태(`State`)는 호출부로 끌어올리고, Composable은 상태를 인자로 받아야 합니다 (Stateless 지향).
2. **Modifier**: 모든 Composable 함수는 `modifier: Modifier = Modifier`를 첫 번째 선택적 파라미터로 받아야 합니다.
3. **Preview (필수)**: **모든 public Composable 함수는 반드시 `@Preview` 어노테이션을 사용한 Preview 함수를 포함해야 합니다.**
   - Preview 함수는 `private`으로 선언하고, `@Preview(showBackground = true)`를 사용합니다.
   - 다양한 상태를 보여주는 것이 좋습니다 (선택됨/선택 안 됨, 활성화/비활성화 등).
   - **복잡한 데이터가 필요한 경우**: `@PreviewParameter`와 `PreviewParameterProvider`를 사용하여 Mock 데이터를 주입합니다.
     ```kotlin
     class UserPreviewParameterProvider : PreviewParameterProvider<User> {
         override val values = sequenceOf(
             User("John", "john@example.com"),
             User("Jane", "jane@example.com")
         )
     }
     
     @Preview(showBackground = true)
     @Composable
     private fun UserCardPreview(
         @PreviewParameter(UserPreviewParameterProvider::class) user: User
     ) {
         UserCard(user = user)
     }
     ```
   - 예외:
     * 내부 전용 컴포넌트(`internal` 함수)는 선택적으로 작성 가능
     * Navigation Graph Builder 확장 함수 (`NavGraphBuilder` 확장 함수)
     * ViewModel이나 Repository 같은 비UI 컴포넌트

## File Structure
- **One Component per File**: 하나의 파일에는 하나의 주요 `@Composable` 함수와 해당 `@Preview`만 위치시킵니다.
   - 예외: 비공개(`private`) 하위 컴포넌트나 data class, enum 등은 같은 파일에 둘 수 있습니다.

- **Component Reusability Decision (컴포넌트 재사용성 결정 규칙)**: 재사용 여부가 불확실한 컴포넌트는 별도 파일로 분리하지 말고, 사용하는 파일 내부에 `private` 함수로 작성합니다.
   - **원칙**: YAGNI (You Aren't Gonna Need It) - 필요할 때까지 분리하지 않습니다.
   - **규칙**:
     * 재사용 여부가 불확실한 경우 → 같은 파일에 `private` 함수로 작성
     * 한 곳에서만 사용되는 경우 → 같은 파일에 `private` 함수로 작성
     * 여러 곳에서 이미 사용 중인 경우 → 별도 파일로 분리 (public 또는 internal)
   - **나중에 재사용이 필요해지면**:
     * `private` → `internal` 또는 `public`으로 변경
     * 별도 파일로 분리
   - **예시**:
     * `TabItem`이 `AfternoteTabRow`에서만 사용 → `AfternoteTabRow.kt` 내부에 `private fun TabItem()` 작성
     * `RecipientItem`이 `RecipientList`에서만 사용 → `RecipientList.kt` 내부에 `private fun RecipientItem()` 작성
     * `ProcessingMethodItem`이 여러 화면에서 사용 → 별도 파일 `ProcessingMethodItem.kt`로 분리

- **File Length Limit**: 파일이 400줄을 넘어가면 여러 파일로 분리해야 합니다.
   - 파일이 너무 길어지면 가독성과 유지보수성이 저하됩니다.
   - 분리 방법:
     * 관련된 기능이나 책임을 기준으로 논리적으로 분리합니다.
     * 공통적으로 사용되는 로직은 별도의 유틸리티 함수나 헬퍼 컴포넌트로 추출합니다.
     * 큰 컴포넌트는 더 작은 하위 컴포넌트들로 분해합니다.
   - 예외: 자동 생성 코드나 데이터 클래스만 포함하는 파일은 예외적으로 더 길 수 있습니다.

- **Folder Structure Reorganization (폴더 구조 재구성)**: 인지 부하(Cognitive Load)를 줄이기 위해 계층별로 다른 파일 수 제한을 적용합니다.
   - **일반 원칙 (Rule of Thumb)**: 일반적으로 폴더당 파일 수를 **15개 이하**로 유지합니다.
   - **계층별 제한 (Layer-Specific Limits)**:
     * **Presentation Layer (엄격: 10-12개)**: UI 관련 폴더(`Screen`, `Component`, `ViewModel` 등)는 복잡도가 높고 파일 간 의존성이 많습니다. 파일이 **10개를 넘으면** 화면 단위나 하위 기능별로 분리합니다.
       - 예: `screen/` 폴더에 10개 이상 → `screen/login/`, `screen/signup/` 등으로 분리
       - 예: `component/edit/` 폴더에 10개 이상 → `component/edit/radio/`, `component/edit/dropdown/` 등으로 분리
     * **Domain Layer (유연: 15-20개)**: UseCase는 독립적이고 자명한 이름을 가집니다. 비즈니스 도메인 단위로 그룹화할 경우 **20개까지** 허용합니다.
       - 예: `domain/user/` 폴더에 UseCase가 20개까지는 허용
     * **Data Layer (관대: 20개+)**: DTO나 Mapper는 단순한 데이터 구조입니다. 불필요한 중첩을 피하기 위해 **20-25개까지** 허용합니다.
       - 예: `data/dto/` 폴더에 DTO가 20개 이상이어도 도메인별로 명확히 구분되면 허용
   - **재구성 전략 (Reorganization Strategy)**:
     * **Feature 우선, Layer 차순**: Google 가이드와 Clean Architecture 원칙에 따라 **기능(Feature)별로 먼저 그룹화**하고, 그 다음 계층(Layer)별로 그룹화합니다.
       - 권장: `feature/mainpage/presentation/component/edit/`
       - 비권장: `presentation/component/mainpage/edit/`
     * 재구성 방법:
       - 관련된 파일들을 논리적으로 묶을 수 있는 하위 폴더를 생성합니다.
       - 기존 파일들을 적절한 하위 폴더로 이동합니다.
       - 패키지 선언을 새로운 폴더 구조에 맞게 업데이트합니다.
   - **예외**: 자동 생성 파일이나 설정 파일이 많은 경우는 예외적으로 더 많은 파일을 허용할 수 있습니다.

## Component Spacing
- 특정 컴포넌트(예: Text)에만 `padding`을 사용하여 다음 컴포넌트와의 간격을 처리하지 말아야 합니다.
- 모든 컴포넌트에 일관되게 간격 처리 방법을 적용해야 합니다.
- 예외: 컴포넌트 내부 여백이 필요한 경우 (예: 배경이 있는 Box 내부의 Text, 버튼 내부의 Text 등)에는 `padding` 사용 가능

## Rem-based Responsive Design (rem 기반 반응형 디자인) - Critical

### 원칙
**"rem" 개념**: 화면 크기에 따라 동적으로 조정되는 단위. Android에서는 `weight`을 사용하여 구현합니다.

### 핵심 규칙
1. **컴포넌트 크기**: 피그마의 dp 값을 그대로 사용 (예: `height(56.dp)`, `width(350.dp)`)
2. **Padding과 Spacing**: `weight`을 사용한 가변 패딩/간격 적용
   - 화면 가장자리 padding: 고정값 허용 (예: `padding(horizontal = 20.dp)`)
   - **내부 간격**: `Spacer(Modifier.weight())` 사용하여 화면 크기에 따라 동적 조정
   - 작은 간격(8dp 이하): 고정값 허용 (예: `Spacer(Modifier.height(8.dp))`)
3. **공통 컴포넌트 오버로딩**: 비슷한 컴포넌트는 오버로딩으로 재사용
   - 예: `TopBar(title, onBackClick)`, `TopBar(title, step, onBackClick)`
   - 예: `ClickButton(color, title, onClick)` - 공통 버튼 컴포넌트

### 구현 가이드

#### ✅ 올바른 예 (rem 적용)
```kotlin
Column {
    Spacer(modifier = Modifier.weight(0.15f))  // 가변 간격
    
    OutlineTextField(...)
    
    Spacer(modifier = Modifier.height(8.dp))   // 작은 간격은 고정값 OK
    
    ClickButton(...)  // 공통 컴포넌트 재사용
    
    Spacer(modifier = Modifier.weight(1f))     // 가변 간격
}
```

#### ❌ 잘못된 예 (rem 미적용)
```kotlin
Column {
    Spacer(modifier = Modifier.height(24.dp))  // ❌ 고정 간격
    Spacer(modifier = Modifier.height(16.dp))  // ❌ 고정 간격
    Spacer(modifier = Modifier.height(169.dp)) // ❌ 고정 간격 (큰 간격)
    
    Button(...) { ... }  // ❌ 매번 직접 구현
}
```

### 공통 컴포넌트 패턴

#### 1. Header 컴포넌트 오버로딩
```kotlin
// 하나의 파일에 여러 버전 제공
@Composable
fun Header(title: String, onBackClick: () -> Unit)

@Composable
fun Header(title: String, step: Int, onBackClick: () -> Unit)

@Composable
fun Header(title: String, onBackClick: () -> Unit, onActionClick: () -> Unit)
```

#### 2. Button 컴포넌트 재사용
```kotlin
// 공통 버튼 컴포넌트
@Composable
fun ClickButton(
    color: Color,
    title: String,
    onButtonClick: () -> Unit,
    modifier: Modifier = Modifier
)
```

### 적용 우선순위
1. **큰 간격 (24dp 이상)**: `Spacer(Modifier.weight())` 사용
2. **중간 간격 (8-24dp)**: 상황에 따라 weight 또는 고정값
3. **작은 간격 (8dp 이하)**: 고정값 허용
4. **화면 가장자리 padding**: 고정값 허용 (일관성 유지)
5. **컴포넌트 크기**: 항상 고정 dp 값 사용

## Drawable Resources
- SVG나 PNG를 그대로 가져다 쓸 때는 `Modifier.size()`를 설정하지 말아야 합니다.
- drawable 파일에 이미 정의된 크기를 그대로 사용해야 합니다.
- 예외: 특별한 경우에만 크기 조정이 필요할 수 있으나, 일반적으로는 원본 크기를 유지합니다.

## Example
```kotlin
@Composable
fun MyScreen(
    uiState: MyUiState,
    onButtonClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(modifier = modifier) {
        // ...
    }
}

@Preview(showBackground = true)
@Composable
private fun MyScreenPreview() {
    AfternoteTheme {
        MyScreen(
            uiState = MyUiState(),
            onButtonClick = {}
        )
    }
}
```

---

# 2.5. Import Rules (임포트 규칙) - Critical

## Import Rules (임포트 규칙 - 중요)

### 1. Always Include Full Import Statements (항상 전체 임포트 문 포함)
- **ALWAYS include full import statements** for every class, function, and extension used in the code snippet.
  - *Reason*: Android Studio often fails to auto-import extension functions and Compose delegates.
  - 코드 스니펫에서 사용되는 모든 클래스, 함수, 확장 함수에 대해 항상 전체 임포트 문을 포함해야 합니다.
  - *이유*: Android Studio는 종종 확장 함수와 Compose delegate의 자동 임포트에 실패합니다.

### 2. Explicitly Import Extension Functions (확장 함수 명시적 임포트)
- **Never assume extension functions are globally available.** Always add the import line explicitly.
- 다음 확장 함수들은 자동 임포트되지 않으므로 명시적으로 임포트해야 합니다:
  - `androidx.core.view.isVisible` → `import androidx.core.view.isVisible`
  - `androidx.lifecycle.compose.collectAsStateWithLifecycle` → `import androidx.lifecycle.compose.collectAsStateWithLifecycle`
  - `androidx.compose.ui.platform.LocalContext` → `import androidx.compose.ui.platform.LocalContext`
  - `androidx.compose.ui.platform.LocalDensity` → `import androidx.compose.ui.platform.LocalDensity`
  - `androidx.compose.ui.platform.LocalFocusManager` → `import androidx.compose.ui.platform.LocalFocusManager`
  - *Instruction*: 이들이 전역적으로 사용 가능하다고 가정하지 마세요. 항상 명시적으로 임포트 라인을 추가하세요.

### 3. Jetpack Compose Imports (Jetpack Compose 임포트)
- **Always import `androidx.compose.runtime.*` delegates when using `by` keyword:**
  - `import androidx.compose.runtime.getValue`
  - `import androidx.compose.runtime.setValue`
  - `import androidx.compose.runtime.remember`
  - `by` 키워드를 사용할 때는 항상 `androidx.compose.runtime.*` delegate를 임포트해야 합니다.
- **Avoid wildcard imports** (e.g., `import androidx.compose.material3.*`) unless strictly necessary.
  - Use explicit imports to prevent `Unresolved Reference` errors.
  - 와일드카드 임포트를 피하고 명시적 임포트를 사용하여 `Unresolved Reference` 오류를 방지하세요.

### 4. Standard Import Rules (표준 임포트 규칙)
- **NEVER import `android.R`**: 절대 `android.R`을 임포트하지 마세요. 항상 애플리케이션 패키지의 `R` 클래스를 사용하세요 (예: `com.kuit.afternote.R`).
- **NO Wildcard Imports**: `import java.util.*` 같은 와일드카드 임포트를 사용하지 마세요. 명시적으로 특정 클래스를 임포트하세요.
- **Prefer AndroidX**: 항상 레거시 `android.support.*` 패키지보다 `androidx.*` 패키지를 선호하세요.

### 5. No Hallucinated Imports (환각 임포트 금지)
- **Do not invent extension functions** that do not exist in standard AndroidX libraries.
  - 표준 AndroidX 라이브러리에 존재하지 않는 확장 함수를 만들어내지 마세요.
- **Verify existence**: Before generating code, verify that all imported classes/functions exist in:
  - Standard Android SDK
  - Commonly used libraries (Hilt, Retrofit, Room, Compose, etc.)
  - 코드 생성 전에 모든 임포트된 클래스/함수가 다음에 존재하는지 확인하세요:
    * 표준 Android SDK
    * 일반적으로 사용되는 라이브러리 (Hilt, Retrofit, Room, Compose 등)

### 6. Generated Code Handling (생성된 코드 처리)
- **Hilt & ViewBinding**:
  - When referencing Hilt generated classes (`Hilt_MainActivity`), DO NOT import them manually.
  - Hilt 생성 클래스를 참조할 때는 수동으로 임포트하지 마세요.
  - For ViewBinding, ensure imports match the XML file name (e.g., `FragmentHomeBinding` for `fragment_home.xml`).
  - ViewBinding의 경우, 임포트가 XML 파일 이름과 일치하는지 확인하세요 (예: `fragment_home.xml` → `FragmentHomeBinding`).

### 7. Verification Step (검증 단계)
- **Before generating the final code block, double-check:**
  1. Are all `Modifier` extensions (padding, fillMaxSize, fillMaxWidth, etc.) imported?
     - 모든 `Modifier` 확장 함수가 임포트되었는가? (padding, fillMaxSize, fillMaxWidth 등)
  2. Are `getValue`/`setValue` imported for state delegates (`by remember { mutableStateOf() }`)?
     - 상태 delegate (`by remember { mutableStateOf() }`)를 사용할 때 `getValue`/`setValue`가 임포트되었는가?
  3. Are there any ambiguous imports (e.g., `android.R` vs `com.kuit.afternote.R`)?
     - 모호한 임포트가 있는가? (예: `android.R` vs `com.kuit.afternote.R`) → 앱의 R 클래스를 사용하세요.
  4. Are all Compose UI components properly imported?
     - 모든 Compose UI 컴포넌트가 제대로 임포트되었는가?
  5. Are extension functions from KTX libraries (fragment-ktx, activity-ktx) imported correctly?
     - KTX 라이브러리(fragment-ktx, activity-ktx)의 확장 함수가 올바르게 임포트되었는가?

## Kotlin & Compose Style
- 가능한 한 `var`보다 `val`을 사용하세요.
- Jetpack Compose에서 `Modifier` 체이닝 순서를 선호하세요: Size -> Layout -> Drawing -> Event Listeners.
- 기본적으로 Material3 디자인 시스템 컴포넌트를 사용하세요.
- Coroutines: ViewModel에서는 `viewModelScope`를, Fragments/Activities에서는 `LifecycleScope`를 사용하세요.

## Behavior
- 표준 라이브러리 솔루션이 존재하면, 지정되지 않은 한 3rd party 라이브러리보다 표준 라이브러리를 선호하세요.
- 오류를 수정할 때 임포트가 왜 잘못되었는지 설명하세요 (예: "사용하지 않는 임포트 제거").

---

# 3. Navigation Rules (네비게이션 규칙)

## Type-Safe Navigation
1. **Serializable Routes**: 모든 Route는 `kotlinx.serialization`의 `@Serializable` 어노테이션을 사용한 `sealed interface` 또는 `sealed class`로 정의합니다.
   - 문자열 하드코딩(예: "home/{id}")은 금지합니다.
   - 타입 안전한 네비게이션을 위해 sealed interface 또는 sealed class를 사용합니다.

2. **Domain Navigation (도메인 간 네비게이션)**
   - **다른 도메인으로 navigate 할 때는 인터페이스를 사용하세요.**
   - navgraph 내부에서 다른 도메인을 직접 아는 것은 지양합니다.
   - 도메인 간 의존성을 줄이고 모듈성을 유지하기 위해 인터페이스를 통해 네비게이션을 처리합니다.
   - 각 도메인은 자신의 Navigator 인터페이스를 정의하고, 구현체는 app 레벨에서 생성합니다.

## Navigation Example

```kotlin
// 1. core/navigation에 Navigator 인터페이스 정의 (다른 도메인으로 가는 메서드만)
interface OnboardingNavigator {
    fun goToMainPage(route: MainPageRoute)
}

interface MainPageNavigator {
    fun goToOnboarding(route: OnboardingRoute)
}

// 2. app/navigation/navigator에 구현체 생성
class OnboardingNavigatorImpl(
    private val navController: NavController
) : OnboardingNavigator {
    override fun goToMainPage(route: MainPageRoute) {
        navController.navigate(route)
    }
}

class MainPageNavigatorImpl(
    private val navController: NavController
) : MainPageNavigator {
    override fun goToOnboarding(route: OnboardingRoute) {
        navController.navigate(route)
    }
}

// 3. Route 정의 (@Serializable 필수)
sealed interface OnboardingRoute {
    @Serializable
    data object SplashRoute : OnboardingRoute
    
    @Serializable
    data object LoginRoute : OnboardingRoute
    // ...
}

sealed interface MainPageRoute {
    @Serializable
    data object MainEmptyRoute : MainPageRoute
    
    @Serializable
    data class DetailRoute(val id: Long) : MainPageRoute
    // ...
}

// 4. NavGraph에서 Navigator 구현체 생성 및 전달
@Composable
fun NavGraph(navHostController: NavHostController) {
    val onboardingNavigator = remember {
        OnboardingNavigatorImpl(navHostController)
    }
    val mainPageNavigator = remember {
        MainPageNavigatorImpl(navHostController)
    }
    
    NavHost(navController = navHostController, startDestination = "...") {
        onboardingNavGraph(navController, onboardingNavigator)
        mainPageNavGraph(navController, mainPageNavigator)
    }
}

// 5. 각 도메인 navgraph에서 Navigator 인터페이스 사용
fun NavGraphBuilder.onboardingNavGraph(
    navController: NavController,
    onboardingNavigator: OnboardingNavigator
) {
    composable<OnboardingRoute.SplashRoute> {
        // 같은 도메인 내부는 navController 직접 사용
        SplashScreen(
            onStartClick = { navController.navigate(OnboardingRoute.SignUpRoute) }
        )
    }
    
    // 다른 도메인으로 가는 경우 Navigator 인터페이스 사용
    // onboardingNavigator.goToMainPage(MainPageRoute.SomeRoute)
}
```

---

# 4. Dependency Injection Rules (Hilt 규칙)

1. **Constructor Injection**: 가능한 모든 클래스(`RepositoryImpl`, `UseCase`, `ViewModel`)는 생성자 주입(`@Inject constructor`)을 사용합니다.
2. **ViewModel**: `@HiltViewModel`을 사용하고, `SavedStateHandle`이 필요한 경우 생성자에 포함합니다.
3. **Modules**:
   - `Repository` 바인딩은 `@Binds`를 사용하여 추상화와 구현체를 연결합니다.
   - 외부 라이브러리(Retrofit, Room 등) 인스턴스는 `@Provides`를 사용합니다.
   - 모듈은 `di` 패키지 하위에 위치시킵니다.

## Example
```kotlin
@HiltViewModel
class MyViewModel @Inject constructor(
    private val myUseCase: MyUseCase
) : ViewModel() { ... }

@Module
@InstallIn(SingletonComponent::class)
abstract class DataModule {
    @Binds
    abstract fun bindMyRepository(
        impl: MyRepositoryImpl
    ): MyRepository
}
```

---

# 5. Code Quality & Formatting (코드 품질)

## Role & Goal
You are a Senior Android Developer with strict adherence to Kotlin coding standards and static analysis rules.
**Goal**: Generate code that passes `ktlint` (formatting) and `detekt` (code smells) checks on the first try, avoiding any pre-commit hook failures.

## Critical Instructions for Code Generation

### 1. Context & Config Awareness
- **Before generating code, briefly scan `.editorconfig` and `detekt.yml` in the project root** if they exist to understand custom indentations or max line lengths.
- If no config is found, default to **Standard Kotlin Style Guide**.

### 2. Import Rules (Strict Enforcement)
**Note**: 자세한 Import 규칙은 Section 2.5를 참고하세요. 여기서는 ktlint 관련 핵심 규칙만 명시합니다.

- **NO Wildcard Imports**: Never use `import foo.*`. Always import individual classes.
  - 예: `import androidx.compose.material3.*` ❌
  - 예: `import androidx.compose.material3.Text`, `import androidx.compose.material3.Button` ✅
- **Import Order**: Imports must be ordered in lexicographic order without any empty lines in-between with "java", "javax", "kotlin" and aliases in the end.

### 3. Ktlint Compliance (Formatting) - Critical

#### 3.1 Formatting Rules
- **Indentation**: Use **4 spaces** for indentation. Do not use tabs.
- **Spacing**:
  - Put spaces around operators (`+`, `-`, `=`, etc.).
  - Put a space before `{` and after `if`, `for`, `while`.
  - Example: `if (condition) {` ✅, `if(condition){` ❌
- **Trailing Comma**: Use trailing commas in multi-line parameter lists or value arguments (if Kotlin version supports it).
- **Final Newline**: Ensure every file ends with a single newline character.
- **Blank Lines**: Limit consecutive blank lines to one.
- **Line Breaks**: Avoid unexpected newlines before `.` in chained calls. Keep chained modifiers on the same line or properly formatted.

#### 3.2 Common Ktlint Violations to Avoid
- Unexpected newline before `.` in modifier chains
- Missing newline after `,` in multi-line parameter lists
- Unused imports (always remove unused imports)
- Import ordering violations

### 4. Detekt Compliance (Complexity & Smells) - Critical

#### Function Complexity
- **Function Length**: Keep functions short and focused (aim for < 20 lines). Break down complex logic into helper functions.
- **Max Line Length**: Limit lines to 120 characters (or 100 depending on your team's rule). Wrap long chained calls or parameters.
- **Long Parameter List**: Functions with more than 10 parameters should use data classes or be refactored.
  - Use `@Suppress("LongParameterList")` only when absolutely necessary and document why.

#### Code Smells
- **Magic Numbers**: Avoid hardcoded numbers. Extract them to `const val` or strict named constants, except for obvious values like 0, 1, or -1.
  - 예: `val timeout = 5000` ❌ → `const val TIMEOUT_MS = 5000` ✅
- **Nested Blocks**: Avoid deep nesting (max depth: 4). Use guard clauses (`return` early) to flatten `if-else` structures.
- **Empty Blocks**: Never leave `catch` or `if` blocks empty. Add a comment explaining why it's empty or handle the exception properly.
- **Top-Level Declarations**: Group constants, extension functions, and classes logically.

#### Detekt Rules
- **Detekt**: 프로젝트의 `detekt.yml` 규칙을 준수합니다.
  - 함수의 매개변수가 10개를 넘으면 data class로 묶거나 리팩토링을 고려합니다.
  - `Magic Number` 사용을 지양하고 상수로 정의합니다.
  - 함수 복잡도 제한을 준수합니다.

### 5. Naming Convention
- Composable: `PascalCase` (예: `LoginScreen`)
- ViewModel: `PascalCase` + `ViewModel` (예: `LoginViewModel`)
- Repository/UseCase: `PascalCase` + `Repository`/`UseCase` (예: `LoginRepository`, `LoginUseCase`)
- Route: `PascalCase` + `Route` (예: `LoginRoute`)

## Output Format
- Provide clean, production-ready Kotlin code.
- Do not include comments like "// formatting fix" unless necessary for explanation.
- All code must pass ktlint and detekt checks on first commit attempt.

---

# 6. Resource Management (리소스 관리)

1. **Drawable**:
   - 아이콘은 `Icon` 컴포저블을 사용하고, `contentDescription`을 반드시 지정합니다.
   - 이미지 리소스 사용 시 `painterResource(R.drawable.name)`을 사용합니다.
   - Modifier로 사이즈를 강제하기보다, 벡터 리소스 자체의 크기를 유지하거나 `ContentScale`을 활용합니다.

2. **Strings**:
   - 모든 UI 텍스트는 `strings.xml`에 정의하여 사용합니다 (`stringResource(R.string.key)`).
   - 하드코딩된 문자열은 금지합니다.

---

# 7. Testing Rules (테스트 규칙)

1. **Unit Test**:
   - `Domain Layer`(`UseCase`)와 `ViewModel`은 100%에 가까운 테스트 커버리지를 지향합니다.
   - `MockK`를 사용하여 의존성을 모킹합니다.

2. **Naming**:
   - 테스트 함수명은 행위를 명확히 기술합니다 (예: `fetchUser_whenSuccess_returnsUser`).

---

# 8. Git & Commit Rules (커밋 규칙)

## ⚠️ Critical: 커밋 및 푸시 규칙 (Critical: Commit & Push Rule)

**사용자가 명시적으로 커밋 또는 푸시를 요청하지 않으면 절대 커밋하거나 푸시하지 않습니다.**

### 1. 커밋 금지 원칙
- 사용자가 "커밋해", "commit", "git commit" 등 명시적으로 커밋을 요청하지 않으면 커밋하지 않습니다
- 코드 변경만 하고 커밋은 하지 않습니다
- 사용자가 커밋을 요청하지 않았는데 커밋한 경우, 즉시 취소해야 합니다

### 2. 커밋 허용 조건
- 사용자가 명시적으로 "커밋해", "commit", "git commit" 등을 요청한 경우에만 커밋합니다
- 사용자가 "커밋하고 푸시해"라고 요청한 경우에만 커밋합니다

### 3. 푸시 금지 원칙
- 사용자가 "푸시해", "push", "push origin", "git push" 등 명시적으로 푸시를 요청하지 않으면 푸시하지 않습니다
- 커밋만 하고 푸시는 하지 않습니다
- 사용자가 푸시를 요청하지 않았는데 푸시한 경우, 즉시 취소해야 합니다

### 4. 푸시 허용 조건
- 사용자가 명시적으로 "푸시해", "push", "git push" 등을 요청한 경우에만 푸시합니다
- 사용자가 "커밋하고 푸시해"라고 요청한 경우에만 푸시합니다

### 5. 취소 방법
- 실수로 커밋한 경우: `git reset --soft HEAD~1` (변경사항은 유지) 또는 `git reset --hard HEAD~1` (변경사항도 제거)
- 실수로 푸시한 경우: `git reset --hard HEAD~1` 후 `git push origin {branch-name} --force-with-lease`로 원격에서도 제거

## Conventional Commits
커밋 메시지는 아래 형식을 따릅니다:
`type(scope): subject`

- **Types**:
  - `feat`: 새로운 기능 추가
  - `fix`: 버그 수정
  - `refactor`: 코드 리팩토링 (기능 변경 없음)
  - `style`: 포맷팅, 세미콜론 누락 등 (코드 변경 없음)
  - `docs`: 문서 수정
  - `test`: 테스트 추가/수정
  - `chore`: 빌드 태스크, 패키지 매니저 설정 등
  - `build`: 빌드 시스템 또는 외부 종속성 변경
  - `ci`: CI 설정 파일 및 스크립트 변경
  - `perf`: 성능 개선

## Example
- `feat(auth): add login usecase`
- `fix(ui): correct padding in home screen`
- `refactor(navigation): apply navigator pattern`

---

# 9. Documentation (문서화)

1. **Public API (필수)**: **모든 `public` 함수나 클래스(특히 `UseCase`, `Repository` 인터페이스)에는 반드시 KDoc 형식의 주석을 작성해야 합니다.**
   - Detekt의 `undocumented-public-function` 규칙을 준수하기 위함입니다.
   - KDoc은 함수의 역할, 파라미터, 반환값을 명확히 설명해야 합니다.
   - 예외: 단순한 data class나 enum은 선택적으로 작성 가능

2. **Complex Logic**: 복잡한 비즈니스 로직이 들어가는 곳에는 주석을 통해 '왜(Why)' 이렇게 구현했는지 설명합니다.

3. **README 업데이트**: 파일을 변경할 때마다 README 변경이 필요한지 체크하고, 필요하면 반드시 변경해야 합니다.

## Example
```kotlin
/**
 * 사용자의 로그인 상태를 확인하고, 토큰을 갱신합니다.
 *
 * @param forceRefresh 강제로 토큰을 갱신할지 여부
 * @return 갱신된 토큰 정보
 */
suspend fun checkAuth(forceRefresh: Boolean): AuthToken
```

---

# 10. Test Code Verification (테스트 코드 확인 규칙) - Critical

## 코드 변경 시 테스트 디렉토리 확인 및 테스트 코드 추가

코드를 생성하거나 수정할 때마다 **반드시** 다음을 확인하고 필요하면 테스트 코드를 추가해야 합니다:

### 1. 테스트 디렉토리 확인
- `app/src/test/java/com/kuit/afternote/` (Unit Test)
- `app/src/androidTest/java/com/kuit/afternote/` (Instrumented Test)

### 2. 테스트 코드 추가가 필요한 경우

다음과 같은 코드 변경 시 해당하는 테스트 디렉토리에 테스트 코드를 추가해야 합니다:

#### UseCase 추가/수정 시
- **위치**: `app/src/test/java/com/kuit/afternote/feature/{feature_name}/domain/usecase/`
- **파일명**: `{UseCaseName}Test.kt`
- **내용**: UseCase의 모든 메서드에 대한 단위 테스트 작성
- **예시**: `LoginUseCase` 추가 시 → `LoginUseCaseTest.kt` 생성

#### ViewModel 추가/수정 시
- **위치**: `app/src/test/java/com/kuit/afternote/feature/{feature_name}/presentation/viewmodel/`
- **파일명**: `{ViewModelName}Test.kt`
- **내용**: ViewModel의 상태 변경, 이벤트 처리에 대한 단위 테스트 작성
- **예시**: `LoginViewModel` 추가 시 → `LoginViewModelTest.kt` 생성

#### Repository Interface 추가/수정 시
- **위치**: `app/src/test/java/com/kuit/afternote/feature/{feature_name}/domain/repository/`
- **파일명**: `{RepositoryName}Test.kt` (인터페이스 테스트는 선택적)
- **참고**: Repository 구현체(`Impl`)는 Data Layer이므로 실제 구현에 따라 테스트 작성

#### 복잡한 비즈니스 로직 추가 시
- Domain Layer의 복잡한 로직이 있는 경우 단위 테스트 작성
- 유틸리티 함수나 헬퍼 클래스 추가 시 테스트 작성

### 3. 테스트 코드 작성 규칙

#### 테스트 파일 구조
```kotlin
package com.kuit.afternote.feature.{feature_name}.domain.usecase

import org.junit.Test
import org.junit.Assert.*
// ... 필요한 임포트

class {UseCaseName}Test {
    
    @Test
    fun `methodName_whenCondition_returnsExpectedResult`() {
        // Given
        // When
        // Then
    }
}
```

#### 테스트 네이밍 규칙
- 테스트 함수명: `methodName_whenCondition_returnsExpectedResult` 형식
- 예시: `login_whenSuccess_returnsUser()`, `login_whenInvalidCredentials_throwsException()`

#### 테스트 작성 시 주의사항
- MockK를 사용하여 의존성을 모킹합니다
- Given-When-Then 패턴을 사용합니다
- 모든 엣지 케이스를 테스트합니다

### 4. 확인 절차

코드 변경 후 다음을 확인:

1. **UseCase/ViewModel 추가 여부 확인**
   - 추가했다면 → 해당 테스트 디렉토리에 테스트 파일이 있는지 확인
   - 없으면 → 테스트 파일 생성 및 테스트 코드 작성

2. **기존 테스트 파일 확인**
   - 수정한 코드에 해당하는 기존 테스트 파일이 있는지 확인
   - 있으면 → 수정된 코드에 맞게 테스트 업데이트 필요 여부 확인

3. **테스트 실행 가능 여부 확인**
   - 작성한 테스트가 컴파일되는지 확인
   - 테스트가 실제로 실행 가능한지 확인

### 5. 예외 사항

다음의 경우는 테스트 코드 작성이 선택적입니다:
- 단순한 data class나 enum 추가
- UI 컴포넌트만 추가 (Composable 함수)
- 단순한 확장 함수 추가
- 설정 파일이나 상수만 추가

---

# 11. Branch Workflow Rules (브랜치 작업 규칙)

## 기본 원칙

**변경사항은 항상 주제에 맞는 브랜치에서 작업해야 합니다.**

## ⚠️ Critical: 자동 브랜치 전환 규칙 (Critical: Auto Branch Switching Rule)

**사용자가 어떤 브랜치에서 작업을 요청하든, 반드시 다음 절차를 따라야 합니다:**

1. **작업 요청 시 즉시 브랜치 확인 및 전환**
   - 사용자의 작업 요청을 받으면 **먼저 현재 브랜치를 확인**합니다 (`git branch --show-current` 또는 `git status`)
   - 작업 내용에 맞는 적절한 브랜치가 이미 존재하는지 확인합니다 (`git branch -a`)
   - **적절한 브랜치가 있으면 즉시 해당 브랜치로 체크아웃**합니다 (`git checkout {branch-name}`)
   - **적절한 브랜치가 없으면 새로 생성하고 체크아웃**합니다 (`git checkout -b {branch-name}`)
   - **이 작업은 코드 생성/수정 전에 반드시 수행해야 합니다**

2. **브랜치 선택 기준**
   - 작업 내용을 분석하여 적절한 브랜치 타입을 결정합니다:
     * 새로운 기능 추가 → `feat/{feature-name}`
     * 버그 수정 → `fix/{bug-description}`
     * 문서 수정 → `docs/{document-name}`
     * 설정/도구 변경 → `chore/{tool-name}`
     * 리팩토링 → `refactor/{component-name}`
   - 기존 브랜치가 작업 내용과 일치하면 해당 브랜치를 사용합니다
   - 기존 브랜치가 없거나 작업 내용과 맞지 않으면 새 브랜치를 생성합니다

3. **예외: 현재 브랜치가 작업 내용과 일치하는 경우**
   - 현재 브랜치가 작업 요청 내용과 정확히 일치하는 경우에만 현재 브랜치에서 작업합니다
   - 예: `feat/login-screen` 브랜치에서 로그인 화면 관련 작업을 요청한 경우

### 규칙

1. **현재 브랜치의 주제와 맞지 않는 변경사항은 별도 브랜치 생성**
   - 예: `feat/afternote` 브랜치에서 작업 중인데 문서 수정이 필요한 경우
   - → `docs/update-readme` 같은 별도 브랜치 생성

2. **브랜치 네이밍 규칙**
   - `feat/`: 새로운 기능
   - `fix/`: 버그 수정
   - `docs/`: 문서 수정
   - `chore/`: 기타 작업 (설정, 도구 등)
   - `refactor/`: 리팩토링

3. **작업 흐름**
   ```
   사용자 작업 요청
   → 현재 브랜치 확인
   → 작업 내용 분석
   → 적절한 브랜치 확인/생성
   → 브랜치 체크아웃
   → 코드 생성/수정
   → 변경사항 커밋
   → 필요시 메인에 병합
   ```

4. **구현 요구 시 브랜치 생성 규칙**
   - **사용자가 어떤 브랜치에서 작업을 요청하든, 작업 내용에 맞는 적절한 브랜치로 자동으로 이동하거나 생성해야 합니다**
   - 사용자가 구현을 요구할 때마다:
     1. 먼저 현재 브랜치를 확인합니다
     2. 작업 내용에 맞는 브랜치가 있는지 확인합니다
     3. 있으면 해당 브랜치로 체크아웃하고, 없으면 새로 생성하고 체크아웃합니다
     4. 그 다음 코드를 생성/수정합니다
   - 브랜치 이름은 작업 내용을 명확히 나타내야 합니다
   - 예: `feat/add-custom-radio-button`, `fix/text-field-padding`, `refactor/move-component-to-core`
   - 작업 완료 후 해당 브랜치에서 커밋하고, 필요시 메인에 병합합니다

5. **병합 제안 규칙 (Merge Suggestion Rules) - 안전 우선**
   - **병합 자동 실행 금지**: 절대 자동으로 병합하지 않습니다. 대신 병합이 필요한 경우 사용자에게 제안만 합니다.
   - **병합 제안 조건**: 작업이 완료되고 다음 조건을 만족하는 경우 병합을 제안할 수 있습니다:
     * 작업이 완료되었고 테스트가 통과한 경우
     * 다른 브랜치와의 충돌이 없는 경우
     * 코드 리뷰가 필요 없는 간단한 변경인 경우 (설정 파일, 문서, 작은 버그 수정 등)
   - **제안 형식**: 병합이 필요하다고 판단되면 다음과 같이 제안합니다:
     ```
     작업이 완료되었습니다. 메인 브랜치에 병합하시겠습니까?
     다음 명령어를 실행하세요:
     git checkout main
     git merge {작업_브랜치}
     git push origin main
     ```
   - **병합 제안하지 않는 경우**: 다음의 경우는 병합을 제안하지 않습니다:
     * 큰 기능 추가나 리팩토링 (코드 리뷰 필요)
     * 다른 팀원과 협의가 필요한 변경
     * 사용자가 명시적으로 병합하지 말라고 한 경우
     * Git 상태가 불확실한 경우 (충돌 가능성, uncommitted changes 등)

6. **예외 상황**
   - 현재 브랜치의 주제와 직접 관련된 변경은 현재 브랜치에서 작업 가능
   - 긴급한 버그 수정은 별도 브랜치 생성 후 메인에 병합

## 예시

### ❌ 잘못된 예
- `feat/afternote` 브랜치에서 README 수정 커밋
- `feat/afternote` 브랜치에서 Gradle 설정 변경 커밋

### ✅ 올바른 예
- README 수정 → `docs/update-readme` 브랜치 생성
- Gradle 설정 변경 → `chore/update-gradle-config` 브랜치 생성
- 각각 메인에 병합 후 `feat/afternote`에 반영

---

# 12. General Guidelines (일반 작업 가이드라인)

## 기본 원칙

1. **주제에 맞는 브랜치에서 작업**
   - 자세한 내용은 Branch Workflow Rules 참고

2. **시도한 해결책 메모**
   - 문제 해결 시 시도한 방법들을 메모해두기
   - 같은 실수를 반복하지 않기 위함

3. **문서화**
   - 중요한 설정이나 해결 방법은 문서로 남기기
   - 다른 팀원이나 미래의 자신을 위해

4. **컴포넌트 프리뷰 필수**
   - 모든 컴포넌트 함수는 반드시 `@Preview` 어노테이션을 사용한 프리뷰 함수를 포함해야 합니다
   - 프리뷰는 컴포넌트의 다양한 상태를 보여주는 것이 좋습니다 (선택됨/선택 안 됨, 활성화/비활성화 등)
   - 예외: 내부 전용 컴포넌트(`internal` 함수)는 선택적으로 작성 가능

5. **Compose 컴포넌트 파일 구조 규칙**
   - 각 파일에는 하나의 `@Composable` 함수와 그에 해당하는 하나의 `@Preview` 함수만 포함해야 합니다
   - 예외: data class나 enum 등은 같은 파일에 포함 가능하거나 별도 파일로 분리 가능
   - 여러 컴포넌트가 필요한 경우 각각 별도 파일로 분리해야 합니다

6. **Drawable 리소스 사용 규칙**
   - SVG나 PNG를 그대로 가져다 쓸 때는 `Modifier.size()`를 설정하지 말아야 합니다
   - drawable 파일에 이미 정의된 크기를 그대로 사용해야 합니다
   - 예외: 특별한 경우에만 크기 조정이 필요할 수 있으나, 일반적으로는 원본 크기를 유지합니다

7. **컴포넌트 간 간격 처리 일관성 규칙**
   - 특정 컴포넌트(예: Text)에만 `padding`을 사용하여 다음 컴포넌트와의 간격을 처리하지 말아야 합니다
   - 모든 컴포넌트에 일관되게 간격 처리 방법을 적용해야 합니다
   - 예외: 컴포넌트 내부 여백이 필요한 경우 (예: 배경이 있는 Box 내부의 Text, 버튼 내부의 Text 등)에는 `padding` 사용 가능

## 파일 변경 시 README 체크 규칙

**파일을 변경할 때마다 README 변경이 필요한지 체크하고, 필요하면 반드시 변경해야 합니다.**

### 체크해야 할 경우

1. **새로운 설정이나 도구 추가**
   - 예: 새로운 라이브러리, 빌드 도구, 개발 환경 설정
   - README의 설정 섹션 업데이트 필요

2. **프로젝트 구조 변경**
   - 예: 폴더 구조 변경, 새로운 모듈 추가
   - README의 프로젝트 구조 설명 업데이트

3. **개발 환경 요구사항 변경**
   - 예: JDK 버전 변경, 새로운 의존성 추가
   - README의 필수 요구사항 섹션 업데이트

4. **빌드/실행 방법 변경**
   - 예: 새로운 빌드 스크립트, 실행 방법 변경
   - README의 빌드/실행 가이드 업데이트

5. **트러블슈팅 정보 추가**
   - 예: 새로운 에러 해결 방법 발견
   - README의 트러블슈팅 섹션에 추가

6. **워크플로우나 규칙 변경**
   - 예: 브랜치 전략 변경, 커밋 규칙 변경
   - README의 관련 섹션 업데이트

### 체크 방법

파일 변경 후 다음을 확인:
1. 이 변경이 다른 개발자에게 영향을 주는가?
2. 이 변경을 이해하기 위해 문서가 필요한가?
3. 이 변경으로 인해 기존 README 내용이 부정확해졌는가?

**모든 답변이 "아니오"가 아니라면 README를 업데이트해야 합니다.**
