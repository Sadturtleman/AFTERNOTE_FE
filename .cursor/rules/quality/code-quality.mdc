---
description: 코드 품질, 포맷팅, 테스트 규칙
globs: **/*.kt
alwaysApply: true
---

# Code Quality & Formatting (코드 품질)

## Role & Goal
You are a Senior Android Developer with strict adherence to Kotlin coding standards and static analysis rules.
**Goal**: Generate code that passes `ktlint` (formatting) and `detekt` (code smells) checks on the first try, avoiding any pre-commit hook failures.

## Critical Instructions for Code Generation

### 1. Context & Config Awareness
- **Before generating code, briefly scan `.editorconfig` and `detekt.yml` in the project root** if they exist to understand custom indentations or max line lengths.
- If no config is found, default to **Standard Kotlin Style Guide**.

### 2. Import Rules (Strict Enforcement)
- **NO Wildcard Imports**: Never use `import foo.*`. Always import individual classes.
- **Import Order**: Imports must be ordered in lexicographic order without any empty lines in-between with "java", "javax", "kotlin" and aliases in the end.

### 3. Ktlint Compliance (Formatting) - Critical

#### Formatting Rules
- **Indentation**: Use **4 spaces** for indentation. Do not use tabs.
- **Spacing**:
  - Put spaces around operators (`+`, `-`, `=`, etc.).
  - Put a space before `{` and after `if`, `for`, `while`.
  - Example: `if (condition) {` ✅, `if(condition){` ❌
- **Trailing Comma**: Use trailing commas in multi-line parameter lists or value arguments (if Kotlin version supports it).
- **Final Newline**: Ensure every file ends with a single newline character.
- **Blank Lines**: Limit consecutive blank lines to one.
- **Line Breaks**: Avoid unexpected newlines before `.` in chained calls. Keep chained modifiers on the same line or properly formatted.

#### Common Ktlint Violations to Avoid
- Unexpected newline before `.` in modifier chains
- Missing newline after `,` in multi-line parameter lists
- Unused imports (always remove unused imports)
- Import ordering violations

### 4. Detekt Compliance (Complexity & Smells) - Critical

#### Function Complexity
- **Function Length**: Keep functions short and focused (aim for < 20 lines). Break down complex logic into helper functions.
- **Max Line Length**: Limit lines to 120 characters (or 100 depending on your team's rule). Wrap long chained calls or parameters.
- **Long Parameter List**: Functions with more than 10 parameters should use data classes or be refactored.
  - **⚠️ Critical: @Suppress는 최후의 수단**
  - **절대 먼저 시도해야 할 것**: `@Suppress`를 사용하기 전에 반드시 코드 구조 개선을 시도해야 합니다.
  - **State Hoisting 패턴 적용 시 파라미터가 많아지는 경우**:
    * **콜백 그룹화**: 3개 이상의 콜백이 있으면 Event Interface나 data class로 묶기 (예: `RecipientCallbacks`, `ProcessingMethodCallbacks`)
    * **UI 상태 캡슐화**: `expanded`, `boxWidth` 같은 UI 상태는 State Class로 묶기 (예: `SelectionDropdownState`)
    * **초기값 처리**: `initialShowTextField`, `initialExpandedItemId` 같은 초기값은 State 생성자로 옮기기
  - **TooManyFunctions 경고 발생 시**:
    * **불필요한 함수 제거**: 사용되지 않는 헬퍼 함수나 중복 함수 제거
    * **책임 분리**: Manager 클래스로 로직 위임 고려 (예: `RecipientManager`, `CategoryManager`)
    * **Private 함수 활용**: 외부에 노출될 필요 없는 함수는 `private`으로 변경 (detekt 설정에서 `ignorePrivate: true`인 경우 카운트 제외)
  - **Use `@Suppress` only when absolutely necessary and document why**: 구조적 개선이 불가능할 때(라이브러리 제약 등)만 사용하고, 단순히 "편해서" 사용하지 마세요.

#### Code Smells
- **Magic Numbers**: Avoid hardcoded numbers. Extract them to `const val` or strict named constants, except for obvious values like 0, 1, or -1.
  - 예: `val timeout = 5000` ❌ → `const val TIMEOUT_MS = 5000` ✅
- **Nested Blocks**: Avoid deep nesting (max depth: 4). Use guard clauses (`return` early) to flatten `if-else` structures.
- **Empty Blocks**: Never leave `catch` or `if` blocks empty. Add a comment explaining why it's empty or handle the exception properly.
- **Top-Level Declarations**: Group constants, extension functions, and classes logically.

#### Detekt Rules
- **Detekt**: 프로젝트의 `detekt.yml` 규칙을 준수합니다.
  - 함수의 매개변수가 10개를 넘으면 data class로 묶거나 리팩토링을 고려합니다.
  - `Magic Number` 사용을 지양하고 상수로 정의합니다.
  - 함수 복잡도 제한을 준수합니다.
- **⚠️ Critical: @Suppress 사용 전 코드 구조 개선 필수**
  - **경험 사례**: State Hoisting 패턴 적용 후 `LongParameterList`와 `TooManyFunctions` 경고가 발생했을 때, `@Suppress`를 사용하는 대신 코드 구조를 개선하여 해결했습니다.
  - **LongParameterList 해결 방법**:
    * 콜백 함수들을 Event Interface로 그룹화 (예: `RecipientCallbacks`)
    * UI 상태를 State Class로 캡슐화 (예: `SelectionDropdownState`)
    * 초기값 파라미터를 State 생성자로 이동
  - **TooManyFunctions 해결 방법**:
    * 불필요한 함수 제거 (사용되지 않는 헬퍼 함수)
    * 책임 분리 (Manager 클래스로 로직 위임)
    * Private 함수 활용 (외부 노출 불필요한 함수는 `private`으로 변경)
  - **원칙**: `@Suppress`는 구조적 개선이 불가능할 때만 사용하고, 항상 먼저 코드 구조 개선을 시도해야 합니다.

### 5. Naming Convention
- Composable: `PascalCase` (예: `LoginScreen`)
- ViewModel: `PascalCase` + `ViewModel` (예: `LoginViewModel`)
- Repository/UseCase: `PascalCase` + `Repository`/`UseCase` (예: `LoginRepository`, `LoginUseCase`)
- Route: `PascalCase` + `Route` (예: `LoginRoute`)

## Output Format
- Provide clean, production-ready Kotlin code.
- Do not include comments like "// formatting fix" unless necessary for explanation.
- All code must pass ktlint and detekt checks on first commit attempt.

## Testing Rules

### Unit Test
- `Domain Layer`(`UseCase`)와 `ViewModel`은 100%에 가까운 테스트 커버리지를 지향합니다.
- `MockK`를 사용하여 의존성을 모킹합니다.

### Naming
- 테스트 함수명은 행위를 명확히 기술합니다 (예: `fetchUser_whenSuccess_returnsUser`).

### Test Code Verification
코드를 생성하거나 수정할 때마다 **반드시** 다음을 확인하고 필요하면 테스트 코드를 추가해야 합니다:

#### UseCase 추가/수정 시
- **위치**: `app/src/test/java/com/kuit/afternote/feature/{feature_name}/domain/usecase/`
- **파일명**: `{UseCaseName}Test.kt`
- **내용**: UseCase의 모든 메서드에 대한 단위 테스트 작성

#### ViewModel 추가/수정 시
- **위치**: `app/src/test/java/com/kuit/afternote/feature/{feature_name}/presentation/viewmodel/`
- **파일명**: `{ViewModelName}Test.kt`
- **내용**: ViewModel의 상태 변경, 이벤트 처리에 대한 단위 테스트 작성

## Documentation

### Public API (필수)
**모든 `public` 함수나 클래스(특히 `UseCase`, `Repository` 인터페이스)에는 반드시 KDoc 형식의 주석을 작성해야 합니다.**
- Detekt의 `undocumented-public-function` 규칙을 준수하기 위함입니다.
- KDoc은 함수의 역할, 파라미터, 반환값을 명확히 설명해야 합니다.
- 예외: 단순한 data class나 enum은 선택적으로 작성 가능

### Complex Logic
복잡한 비즈니스 로직이 들어가는 곳에는 주석을 통해 '왜(Why)' 이렇게 구현했는지 설명합니다.

### ⚠️ Critical: 구조 변경 시 필수 검증 절차
**파일 이동, 패키지 변경, 클래스 리팩토링 등 구조적 변경 작업 시 반드시 다음 절차를 따라야 합니다:**

1. **변경 전 빌드 확인**: 구조 변경 전에 현재 상태가 빌드되는지 확인 (`./gradlew :app:compileDebugKotlin`)
2. **사용처 전체 검색**: 이동/변경할 파일이 사용되는 모든 위치를 `grep`으로 검색하여 리스트업
   - 예: `grep -r "ClassName" app/src/main/java/com/kuit/afternote/feature/mainpage`
3. **Import 경로 일괄 변경**: 모든 사용처의 import 경로를 한 번에 변경 (단계적으로 하지 말고 전체를 먼저 파악)
4. **변수/함수명 변경 시**: 변수명이나 함수명을 변경할 때는 `grep`으로 모든 사용처 확인 후 일괄 변경
5. **변경 후 즉시 빌드 검증**: 파일 이동/변경 후 반드시 빌드하여 컴파일 오류 확인
   - 명령어: `./gradlew :app:compileDebugKotlin`
6. **State/Params 클래스 이동 시**: State 클래스나 Params 클래스를 이동할 때는 해당 클래스를 사용하는 모든 컴포넌트의 import 경로를 확인
7. **중복 제거 시**: 중복 파일을 제거하기 전에 사용처를 모두 확인하고, 하나로 통합한 후 모든 import 경로를 업데이트
8. **경험 사례**: 
   - `IconResourceMapper` 중복 제거 시 `main/`과 `util/`에 모두 존재했으나, 사용처를 확인하지 않고 하나만 삭제하여 빌드 오류 발생
   - `AfternoteItemMapper` 이동 시 `toAfternoteItems` 메서드가 사용되고 있었으나 확인하지 않아 빌드 오류 발생
   - `SelectionDropdown` 리팩토링 시 `boxWidth` 변수를 `state.boxWidth`로 변경하지 않아 빌드 오류 발생
